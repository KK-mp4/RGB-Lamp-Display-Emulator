{"version":3,"mappings":"sbAAA,MAAMA,GAAiB,gJACjBC,GAAuB,iKACvBC,GAAY,+BAClB,SAASC,GAAmBC,EAAKC,EAAO,CACtC,GAAI,MAAQ,aAAeD,IAAQ,eAGnC,OAAOC,CACT,CACA,SAASC,GAAMC,EAAK,CAClB,GAAI,OAAOA,GAAQ,SACjB,OAAOA,EAET,MAAMC,EAAQD,EAAI,cAClB,GAAIC,IAAU,OACZ,MAAO,GAET,GAAIA,IAAU,QACZ,MAAO,GAET,GAAIA,IAAU,OACZ,OAAO,KAET,GAAIA,IAAU,MACZ,MAAO,KAET,GAAIA,IAAU,WACZ,MAAO,KAET,GAAIA,IAAU,YAGd,IAAI,CAACN,GAAU,KAAKK,CAAG,EACrB,OAAOA,EAET,GAAI,CACF,OAAIP,GAAe,KAAKO,CAAG,GAAKN,GAAqB,KAAKM,CAAG,EACpD,KAAK,MAAMA,EAAKJ,EAAkB,EAEpC,KAAK,MAAMI,CAAG,CACtB,MAAC,CACA,OAAOA,CACR,EACH,CC4CA,MAAME,GAAU,KACVC,GAAe,KAEfC,GAAW,KAEXC,GAAU,MACVC,GAAsB,QACtBC,GAAuB,QACvBC,GAAe,QACfC,GAAkB,QAClBC,GAAoB,QACpBC,GAAc,QACdC,GAAqB,QACrBC,GAAe,QAGrB,SAASC,GAAOC,EAAM,CACpB,OAAO,UAAU,GAAKA,CAAI,EAAE,QAAQJ,GAAa,GAAG,EAAE,QAAQL,GAAqB,GAAG,EAAE,QAAQC,GAAsB,GAAG,CAC3H,CAIA,SAASS,EAAiBD,EAAM,CAC9B,OAAOD,GAAOC,CAAI,EAAE,QAAQV,GAAS,KAAK,EAAE,QAAQQ,GAAc,GAAG,EAAE,QAAQX,GAAS,KAAK,EAAE,QAAQC,GAAc,KAAK,EAAE,QAAQM,GAAiB,GAAG,EAAE,QAAQC,GAAmB,GAAG,EAAE,QAAQE,GAAoB,GAAG,EAAE,QAAQJ,GAAc,GAAG,CACtP,CACA,SAASS,EAAeF,EAAM,CAC5B,OAAOC,EAAiBD,CAAI,EAAE,QAAQX,GAAU,KAAK,CACvD,CAOA,SAASc,EAAOH,EAAO,GAAI,CACzB,GAAI,CACF,OAAO,mBAAmB,GAAKA,CAAI,CACpC,MAAC,CACA,MAAO,GAAKA,CACb,CACH,CAIA,SAASI,GAAiBJ,EAAM,CAC9B,OAAOG,EAAOH,EAAK,QAAQV,GAAS,GAAG,CAAC,CAC1C,CAKA,SAASe,GAAWC,EAAY,GAAI,CAClC,MAAMC,EAAM,GACRD,EAAU,KAAO,MACnBA,EAAYA,EAAU,OAAO,CAAC,GAEhC,UAAWE,KAASF,EAAU,MAAM,GAAG,EAAG,CACxC,MAAMG,EAAID,EAAM,MAAM,eAAe,GAAK,GAC1C,GAAIC,EAAE,OAAS,EACb,SAEF,MAAM3B,EAAMqB,EAAOM,EAAE,EAAE,EACvB,GAAI3B,IAAQ,aAAeA,IAAQ,cACjC,SAEF,MAAMC,EAAQqB,GAAiBK,EAAE,IAAM,EAAE,EACrCF,EAAIzB,GACF,MAAM,QAAQyB,EAAIzB,EAAI,EACxByB,EAAIzB,GAAK,KAAKC,CAAK,EAEnBwB,EAAIzB,GAAO,CAACyB,EAAIzB,GAAMC,CAAK,EAG7BwB,EAAIzB,GAAOC,CAEd,CACD,OAAOwB,CACT,CACA,SAASG,GAAgB5B,EAAKG,EAAK,CAIjC,OAHI,OAAOA,GAAQ,UAAY,OAAOA,GAAQ,aAC5CA,EAAM,OAAOA,CAAG,GAEbA,EAGD,MAAM,QAAQA,CAAG,EACZA,EAAI,IAAK0B,GAAS,GAAGT,EAAepB,CAAG,KAAKmB,EAAiBU,CAAI,GAAG,EAAE,KAAK,GAAG,EAEhF,GAAGT,EAAepB,CAAG,KAAKmB,EAAiBhB,CAAG,IAL5CiB,EAAepB,CAAG,CAM7B,CACA,SAAS8B,GAAeC,EAAO,CAC7B,OAAO,OAAO,KAAKA,CAAK,EAAE,IAAKC,GAAMJ,GAAgBI,EAAGD,EAAMC,EAAE,CAAC,EAAE,KAAK,GAAG,CAC7E,CA2FA,MAAMC,GAAiB,eACjBC,GAA0B,aAChC,SAASC,GAAYC,EAAUC,EAAyB,GAAO,CAC7D,OAAOJ,GAAe,KAAKG,CAAQ,GAAKC,GAA0BH,GAAwB,KAAKE,CAAQ,CACzG,CACA,MAAME,GAAoB,WAC1B,SAASC,EAAiBC,EAAQ,GAAIC,EAAc,GAAO,CACzD,OAAKA,EAGEH,GAAkB,KAAKE,CAAK,EAF1BA,EAAM,SAAS,GAAG,CAG7B,CACA,SAASE,GAAqBF,EAAQ,GAAIC,EAAc,GAAO,CAC7D,GAAI,CAACA,EACH,OAAQF,EAAiBC,CAAK,EAAIA,EAAM,MAAM,EAAG,EAAE,EAAIA,IAAU,IAEnE,GAAI,CAACD,EAAiBC,EAAO,EAAI,EAC/B,OAAOA,GAAS,IAElB,KAAM,CAACG,KAAOhB,CAAC,EAAIa,EAAM,MAAM,GAAG,EAClC,OAAQG,EAAG,MAAM,EAAG,EAAE,GAAK,MAAQhB,EAAE,OAAS,IAAIA,EAAE,KAAK,GAAG,IAAM,GACpE,CACA,SAASiB,EAAkBJ,EAAQ,GAAIC,EAAc,GAAO,CAC1D,GAAI,CAACA,EACH,OAAOD,EAAM,SAAS,GAAG,EAAIA,EAAQA,EAAQ,IAE/C,GAAID,EAAiBC,EAAO,EAAI,EAC9B,OAAOA,GAAS,IAElB,KAAM,CAACG,KAAOhB,CAAC,EAAIa,EAAM,MAAM,GAAG,EAClC,OAAOG,EAAK,KAAOhB,EAAE,OAAS,IAAIA,EAAE,KAAK,GAAG,IAAM,GACpD,CACA,SAASkB,GAAgBL,EAAQ,GAAI,CACnC,OAAOA,EAAM,WAAW,GAAG,CAC7B,CACA,SAASM,GAAoBN,EAAQ,GAAI,CACvC,OAAQK,GAAgBL,CAAK,EAAIA,EAAM,OAAO,CAAC,EAAIA,IAAU,GAC/D,CACA,SAASO,GAAiBP,EAAQ,GAAI,CACpC,OAAOK,GAAgBL,CAAK,EAAIA,EAAQ,IAAMA,CAChD,CAIA,SAASQ,GAASR,EAAOS,EAAM,CAC7B,GAAIC,GAAWD,CAAI,EACjB,OAAOT,EAET,MAAMW,EAAQT,GAAqBO,CAAI,EACvC,OAAIT,EAAM,WAAWW,CAAK,EACjBX,EAEFY,EAAQD,EAAOX,CAAK,CAC7B,CAYA,SAASa,GAAUb,EAAOT,EAAO,CAC/B,MAAMuB,EAASC,GAASf,CAAK,EACvBgB,EAAc,CAAE,GAAGjC,GAAW+B,EAAO,MAAM,EAAG,GAAGvB,GACvD,SAAO,OAASD,GAAe0B,CAAW,EACnCC,GAAmBH,CAAM,CAClC,CAIA,SAASJ,GAAWQ,EAAK,CACvB,MAAO,CAACA,GAAOA,IAAQ,GACzB,CACA,SAASC,GAAcD,EAAK,CAC1B,OAAOA,GAAOA,IAAQ,GACxB,CACA,SAASN,EAAQH,KAAST,EAAO,CAC/B,IAAIkB,EAAMT,GAAQ,GAClB,UAAWW,KAAKpB,EAAM,OAAOmB,EAAa,EACxCD,EAAMA,EAAMd,EAAkBc,CAAG,EAAIZ,GAAoBc,CAAC,EAAIA,EAEhE,OAAOF,CACT,CAiCA,SAASG,GAAQC,EAAGC,EAAGC,EAAO,GAAI,CAChC,OAAKA,EAAK,gBACRF,EAAIlB,EAAkBkB,CAAC,EACvBC,EAAInB,EAAkBmB,CAAC,GAEpBC,EAAK,eACRF,EAAIf,GAAiBe,CAAC,EACtBC,EAAIhB,GAAiBgB,CAAC,GAEnBC,EAAK,WACRF,EAAIzC,EAAOyC,CAAC,EACZC,EAAI1C,EAAO0C,CAAC,GAEPD,IAAMC,CACf,CAEA,SAASR,GAASf,EAAQ,GAAIyB,EAAc,CAC1C,GAAI,CAAC9B,GAAYK,EAAO,EAAI,EAC1B,OAAOyB,EAAeV,GAASU,EAAezB,CAAK,EAAI0B,GAAU1B,CAAK,EAExE,KAAM,CAAC2B,EAAW,GAAIC,EAAMC,EAAc,EAAE,GAAK7B,EAAM,QAAQ,MAAO,GAAG,EAAE,MAAM,8BAA8B,GAAK,IAAI,OAAO,CAAC,EAC1H,CAAC8B,EAAO,GAAIC,EAAO,EAAE,GAAKF,EAAY,MAAM,gBAAgB,GAAK,CAAE,GAAE,OAAO,CAAC,EAC7E,CAAE,WAAU,SAAQ,MAAI,EAAKH,GAAUK,CAAI,EACjD,MAAO,CACL,WACA,KAAMH,EAAOA,EAAK,OAAO,EAAGA,EAAK,OAAS,CAAC,EAAI,GAC/C,OACA,WACA,SACA,MACJ,CACA,CACA,SAASF,GAAU1B,EAAQ,GAAI,CAC7B,KAAM,CAACgC,EAAW,GAAIC,EAAS,GAAIC,EAAO,EAAE,GAAKlC,EAAM,MAAM,0BAA0B,GAAK,IAAI,OAAO,CAAC,EACxG,MAAO,CACL,WACA,SACA,MACJ,CACA,CAeA,SAASiB,GAAmBH,EAAQ,CAClC,MAAMqB,EAAWrB,EAAO,UAAYA,EAAO,QAAUA,EAAO,OAAO,WAAW,GAAG,EAAI,GAAK,KAAOA,EAAO,OAAS,IAAMA,EAAO,KAC9H,OAAKA,EAAO,SAGLA,EAAO,SAAW,MAAQA,EAAO,KAAOA,EAAO,KAAO,IAAM,IAAMA,EAAO,KAAOqB,EAF9EA,CAGX,CC9bA,MAAMC,WAAmB,KAAM,CAC7B,aAAc,CACZ,MAAM,GAAG,SAAS,EAClB,KAAK,KAAO,YACb,CACH,CACA,SAASC,GAAiBC,EAASC,EAAOC,EAAU,CAClD,IAAIC,EAAU,GACVH,GAAWE,IACbC,EAAU,GAAGD,EAAS,UAAUA,EAAS,eAAeF,EAAQ,SAAU,MAExEC,IACFE,EAAU,GAAGF,EAAM,YAAYE,MAEjC,MAAMC,EAAa,IAAIN,GAAWK,CAAO,EACzC,cAAO,eAAeC,EAAY,UAAW,CAAE,KAAM,CACnD,OAAOJ,CACR,EAAE,EACH,OAAO,eAAeI,EAAY,WAAY,CAAE,KAAM,CACpD,OAAOF,CACR,EAAE,EACH,OAAO,eAAeE,EAAY,OAAQ,CAAE,KAAM,CAChD,OAAOF,GAAYA,EAAS,KAC7B,EAAE,EACIE,CACT,CAEA,MAAMC,GAAiB,IAAI,IAAI,OAAO,OAAO,CAAC,QAAS,OAAQ,MAAO,QAAQ,CAAC,CAAC,EAChF,SAASC,GAAgBC,EAAS,MAAO,CACvC,OAAOF,GAAe,IAAIE,EAAO,YAAa,EAChD,CACA,SAASC,GAAmBnF,EAAK,CAC/B,GAAIA,IAAQ,OACV,MAAO,GAET,MAAM,EAAI,OAAOA,EACjB,OAAI,IAAM,UAAY,IAAM,UAAY,IAAM,WAAa,IAAM,KACxD,GAEL,IAAM,SACD,GAEL,MAAM,QAAQA,CAAG,EACZ,GAEFA,EAAI,aAAeA,EAAI,YAAY,OAAS,UAAY,OAAOA,EAAI,QAAW,UACvF,CACA,MAAMoF,GAA4B,IAAI,IAAI,CACxC,YACA,kBACA,oBACA,kBACF,CAAC,EACKC,GAAU,qDAChB,SAASC,GAAmBC,EAAe,GAAI,CAC7C,GAAI,CAACA,EACH,MAAO,OAET,MAAMC,EAAcD,EAAa,MAAM,GAAG,EAAE,MAAK,EACjD,OAAIF,GAAQ,KAAKG,CAAW,EACnB,OAELJ,GAAU,IAAII,CAAW,GAAKA,EAAY,WAAW,OAAO,EACvD,OAEF,MACT,CAEA,MAAMC,GAAmC,IAAI,IAAI,CAC/C,IACA,IACA,IACA,IACA,IACA,IACA,IACA,GACF,CAAC,EACD,SAASC,GAAYC,EAAe,CAClC,KAAM,CAAE,QAAO,SAAS,EAAGA,EAC3B,SAASC,EAAQC,EAAK,CACpB,MAAMC,EAAUD,EAAI,OAASA,EAAI,MAAM,OAAS,cAAgB,GAChE,GAAIA,EAAI,QAAQ,QAAU,IAAS,CAACC,EAAS,CAC3C,MAAMC,EAAU,OAAOF,EAAI,QAAQ,OAAU,SAAWA,EAAI,QAAQ,MAAQZ,GAAgBY,EAAI,QAAQ,MAAM,EAAI,EAAI,EAChHG,EAAeH,EAAI,UAAYA,EAAI,SAAS,QAAU,IAC5D,GAAIE,EAAU,GAAKN,GAAiB,IAAIO,CAAY,EAClD,OAAOC,EAAUJ,EAAI,QAAS,CAC5B,GAAGA,EAAI,QACP,MAAOE,EAAU,CAC3B,CAAS,CAEJ,CACD,MAAMG,EAAMxB,GAAiBmB,EAAI,QAASA,EAAI,MAAOA,EAAI,QAAQ,EACjE,MAAI,MAAM,mBACR,MAAM,kBAAkBK,EAAKD,CAAS,EAElCC,CACP,CACD,MAAMD,EAAY,eAA0BE,EAAUC,EAAQ,GAAI,CAChE,MAAMP,EAAM,CACV,QAASM,EACT,QAAS,CAAE,GAAGR,EAAc,SAAU,GAAGS,CAAO,EAChD,SAAU,OACV,MAAO,MACb,EACQP,EAAI,QAAQ,WACd,MAAMA,EAAI,QAAQ,UAAUA,CAAG,EAE7B,OAAOA,EAAI,SAAY,WACrBA,EAAI,QAAQ,UACdA,EAAI,QAAUhD,GAASgD,EAAI,QAASA,EAAI,QAAQ,OAAO,IAErDA,EAAI,QAAQ,OAASA,EAAI,QAAQ,UACnCA,EAAI,QAAU3C,GAAU2C,EAAI,QAAS,CAAE,GAAGA,EAAI,QAAQ,OAAQ,GAAGA,EAAI,QAAQ,KAAO,IAElFA,EAAI,QAAQ,MAAQZ,GAAgBY,EAAI,QAAQ,MAAM,GACpDV,GAAmBU,EAAI,QAAQ,IAAI,IACrCA,EAAI,QAAQ,KAAO,OAAOA,EAAI,QAAQ,MAAS,SAAWA,EAAI,QAAQ,KAAO,KAAK,UAAUA,EAAI,QAAQ,IAAI,EAC5GA,EAAI,QAAQ,QAAU,IAAIQ,EAAQR,EAAI,QAAQ,OAAO,EAChDA,EAAI,QAAQ,QAAQ,IAAI,cAAc,GACzCA,EAAI,QAAQ,QAAQ,IAAI,eAAgB,kBAAkB,EAEvDA,EAAI,QAAQ,QAAQ,IAAI,QAAQ,GACnCA,EAAI,QAAQ,QAAQ,IAAI,SAAU,kBAAkB,IAK5DA,EAAI,SAAW,MAAMS,EAAMT,EAAI,QAASA,EAAI,OAAO,EAAE,MAAM,MAAOjB,IAChEiB,EAAI,MAAQjB,EACRiB,EAAI,QAAQ,gBACd,MAAMA,EAAI,QAAQ,eAAeA,CAAG,EAE/BD,EAAQC,CAAG,EACnB,EACD,MAAMU,GAAgBV,EAAI,QAAQ,cAAgB,OAASA,EAAI,QAAQ,eAAiBP,GAAmBO,EAAI,SAAS,QAAQ,IAAI,cAAc,GAAK,EAAE,EACzJ,GAAIU,IAAiB,OAAQ,CAC3B,MAAMC,EAAO,MAAMX,EAAI,SAAS,KAAI,EAC9BY,EAAUZ,EAAI,QAAQ,eAAiB9F,GAC7C8F,EAAI,SAAS,MAAQY,EAAQD,CAAI,CACvC,MAAeD,IAAiB,SAC1BV,EAAI,SAAS,MAAQA,EAAI,SAAS,KAElCA,EAAI,SAAS,MAAQ,MAAMA,EAAI,SAASU,KAE1C,OAAIV,EAAI,QAAQ,YACd,MAAMA,EAAI,QAAQ,WAAWA,CAAG,EAE7BA,EAAI,SAAS,IACZA,EAAI,QAAQ,iBACd,MAAMA,EAAI,QAAQ,gBAAgBA,CAAG,EAGlCA,EAAI,SAAS,GAAKA,EAAI,SAAWD,EAAQC,CAAG,CACvD,EACQa,EAAS,SAAiB/B,EAASd,EAAM,CAC7C,OAAOoC,EAAUtB,EAASd,CAAI,EAAE,KAAM8C,GAAMA,EAAE,KAAK,CACvD,EACE,SAAO,IAAMV,EACbS,EAAO,OAAS,CAACE,EAAiB,KAAOlB,GAAY,CACnD,GAAGC,EACH,SAAU,CACR,GAAGA,EAAc,SACjB,GAAGiB,CACJ,CACL,CAAG,EACMF,CACT,CCrKA,MAAMG,GAAc,UAAW,CAC7B,GAAI,OAAO,WAAe,IACxB,OAAO,WAET,GAAI,OAAO,KAAS,IAClB,OAAO,KAKT,GAAI,OAAO,OAAW,IACpB,OAAO,OAET,MAAM,IAAI,MAAM,gCAAgC,CAClD,IACMP,GAAQO,GAAY,QAAU,IAAM,QAAQ,OAAO,IAAI,MAAM,4CAA4C,CAAC,GAC1GR,GAAUQ,GAAY,QACtBH,GAAShB,GAAY,CAAE,SAAO,UAAO,CAAE,ECpBvCoB,EAAYC,GAAgB,EAAG,IACxBC,GAAU,IAAMF,EAAU,QAC1BG,GAAiB,IAAMH,EAAU,eACjCI,GAAiB,IAAI9C,IAASnB,EAAQkE,GAAe,EAAIF,GAAc,EAAI,GAAG7C,CAAI,EAClF+C,GAAkB,IAAI/C,IAAS,CAC1C,MAAMgD,EAAaN,EAAU,QAAUA,EAAU,QACjD,OAAO1C,EAAK,OAASnB,EAAQmE,EAAY,GAAGhD,CAAI,EAAIgD,CACtD,EACA,WAAW,iBAAmBF,GAC9B,WAAW,kBAAoBC,GCX/B,SAASE,IAAgB,CACvB,IAAIC,EAAkB,KAClBC,EAAc,GAClB,MAAMC,EAAiBC,GAAa,CAClC,GAAIH,GAAmBA,IAAoBG,EACzC,MAAM,IAAI,MAAM,kBAAkB,CAExC,EACE,MAAO,CACL,IAAK,IAAM,CACT,GAAIH,GAAmB,KACrB,MAAM,IAAI,MAAM,0BAA0B,EAE5C,OAAOA,CACR,EACD,OAAQ,IACCA,EAET,IAAK,CAACG,EAAUC,IAAY,CACrBA,GACHF,EAAcC,CAAQ,EAExBH,EAAkBG,EAClBF,EAAc,EACf,EACD,MAAO,IAAM,CACXD,EAAkB,KAClBC,EAAc,EACf,EACD,KAAM,CAACE,EAAUE,IAAO,CACtBH,EAAcC,CAAQ,EACtBH,EAAkBG,EAClB,GAAI,CACF,OAAOE,EAAE,CACjB,QAAgB,CACHJ,IACHD,EAAkB,KAErB,CACF,EACD,MAAM,UAAUG,EAAUE,EAAI,CAC5BL,EAAkBG,EAClB,MAAMG,EAAY,IAAM,CACtBN,EAAkBG,CAC1B,EACYI,EAAU,IAAMP,IAAoBG,EAAWG,EAAY,OACjEE,GAAc,IAAID,CAAO,EACzB,GAAI,CACF,MAAMlB,EAAIgB,IACV,OAAKJ,IACHD,EAAkB,MAEb,MAAMX,CACrB,QAAgB,CACRmB,GAAc,OAAOD,CAAO,CAC7B,CACF,CACL,CACA,CACA,SAASE,IAAkB,CACzB,MAAMC,EAAW,GACjB,MAAO,CACL,IAAInI,EAAK,CACP,OAAKmI,EAASnI,KACZmI,EAASnI,GAAOwH,MAElBW,EAASnI,GACFmI,EAASnI,EACjB,CACL,CACA,CACA,MAAMgH,EAAc,OAAO,WAAe,IAAc,WAAa,OAAO,KAAS,IAAc,KAAO,OAAO,OAAW,IAAc,OAAkD,GACtLoB,GAAY,YACZC,GAAmBrB,EAAYoB,MAAepB,EAAYoB,IAAaF,GAAe,GACtFI,GAActI,GAAQqI,GAAiB,IAAIrI,CAAG,EAE9CuI,GAAmB,2BACnBN,GAAgBjB,EAAYuB,MAAsBvB,EAAYuB,IAAoC,IAAI,KAC5G,SAASC,GAAaC,EAAI,CACxB,MAAMC,EAAW,GACjB,UAAWC,KAAgBV,GAAe,CACxC,MAAMW,EAAWD,IACbC,GACFF,EAAS,KAAKE,CAAQ,CAEzB,CACD,MAAMC,EAAU,IAAM,CACpB,UAAWD,KAAYF,EACrBE,GAEN,EACE,IAAIE,EAAYL,IAChB,MAAI,UAAWK,IACbA,EAAYA,EAAU,MAAOC,GAAM,CACjC,UACMA,CACZ,CAAK,GAEI,CAACD,EAAWD,CAAO,CAC5B,CChGA,MAAMG,GAAaV,GAAW,UAAU,EAC3BW,GAAsB,gBA4E5B,SAASC,GAAiBC,EAAU,CA2BzC,OAvBgBA,EAAS,IAAKC,GACxB,OAAOA,GAAW,WAEb,KAELA,EAAO,OAAS,EAEVC,GAAYD,EAAOC,EAASA,EAAQ,OAAO,EAK9CD,CACR,EAAE,OAAO,OAAO,CAWnB,CACO,SAASE,EAAiBF,EAAQ,CACvC,SAAOH,IAAuB,GACvBG,CACT,CAIO,SAASG,EAAaC,EAAMC,EAAOC,EAAM,CAC9C,MAAMjB,EAAK,IAAMiB,EAAOD,EAAM,GAAGC,CAAI,EAAID,IAEvC,OAAOT,GAAW,UAAUQ,EAAMf,CAAE,CAKxC,CACO,SAASkB,GAAa,CAC3B,MAAMC,EAAkBZ,GAAW,SACnC,GAAI,CAACY,EAAiB,CACpB,MAAMC,EAAKC,KACX,GAAI,CAACD,EACH,MAAM,IAAI,MAAM,2BAA2B,EAE7C,OAAOA,EAAG,WAAW,IAAI,KAC1B,CACD,OAAOD,CACT,CACO,SAAS1C,IAAmB,CACjC,OAAOyC,EAAY,EAAC,OACtB,CCxIO,SAASI,MAAYL,EAAM,CAChC,MAAMM,EAAU,OAAON,EAAKA,EAAK,OAAS,IAAO,SAAWA,EAAK,IAAK,EAAG,OACrE,OAAOA,EAAK,IAAO,UACrBA,EAAK,QAAQM,CAAO,EAEtB,KAAM,CAACC,EAAMC,CAAI,EAAIR,EACrB,GAAI,CAACO,GAAQ,OAAOA,GAAS,SAC3B,MAAM,IAAI,UAAU,2CAA6CA,CAAI,EAEvE,GAAIC,IAAS,QAAU,OAAOA,GAAS,WACrC,MAAM,IAAI,MAAM,8CAAgDA,CAAI,EAEtE,MAAMlK,EAAM,KAAOiK,EACbT,EAAOG,IACPQ,EAAQC,GAAMZ,EAAK,QAAQ,MAAOxJ,CAAG,EAC3C,GAAImK,EAAM,QAAU,QAAUD,EAAM,CAClC,MAAMG,EAAeH,IACrB,GAAII,GAAMD,CAAY,EACpB,SAAK,QAAQ,MAAMrK,GAAOqK,EACnBA,EAETF,EAAM,MAAQE,CACf,CACD,OAAOF,CACT,CCrBA,MAAMI,WAAgB,KAAM,CAC1B,aAAc,CACZ,MAAM,GAAG,SAAS,EAClB,KAAK,WAAa,IAClB,KAAK,MAAQ,GACb,KAAK,UAAY,GACjB,KAAK,cAAgB,uBACtB,CACH,CACAA,GAAQ,aAAe,GACvB,SAASC,GAAYhI,EAAO,OAC1B,GAAI,OAAOA,GAAU,SACnB,OAAO,IAAI+H,GAAQ/H,CAAK,EAE1B,GAAIiI,GAAQjI,CAAK,EACf,OAAOA,EAET,MAAM6D,EAAM,IAAIkE,IAAQG,IAAM,UAAN,OAAiBlI,EAAM,cAAeA,EAAM,MAAQ,CAAE,MAAOA,EAAM,KAAO,EAAG,MAAM,EAC3G,GAAI,UAAWA,EACb,GAAI,CACF,OAAO,eAAe6D,EAAK,QAAS,CAAE,KAAM,CAC1C,OAAO7D,EAAM,KACd,EAAE,CACT,MAAM,CACA,GAAI,CACF6D,EAAI,MAAQ7D,EAAM,KAC1B,MAAQ,CACD,CACF,CAEH,OAAIA,EAAM,aACR6D,EAAI,WAAa7D,EAAM,YAErBA,EAAM,gBACR6D,EAAI,cAAgB7D,EAAM,eAExBA,EAAM,OACR6D,EAAI,KAAO7D,EAAM,MAEfA,EAAM,QAAU,SAClB6D,EAAI,MAAQ7D,EAAM,OAEhBA,EAAM,YAAc,SACtB6D,EAAI,UAAY7D,EAAM,WAEjB6D,CACT,CAuBA,SAASoE,GAAQjI,EAAO,OACtB,QAAOkI,mBAAO,cAAP,cAAoB,gBAAiB,EAC9C,CA0HA,MAAMC,GAAQ,CACZ,KAAM,YACN,KAAM,kBACR,EAEMC,GAAQ,OAAO,aAAiB,IAAc,aAAgBnC,GAAOA,IAC3E,SAASoC,GAAKC,EAAOnE,EAAMoE,EAAM,CAC/B,OAAIA,GACFC,GAAmBF,EAAOC,CAAI,EAEzB,IAAI,QAASE,GAAY,CAC9BL,GAAM,IAAM,CACVE,EAAM,IAAI,IAAInE,CAAI,EAClBsE,EAAQ,MAAM,CACpB,CAAK,CACL,CAAG,CACH,CACA,SAASD,GAAmBF,EAAOC,EAAM,CACnCA,GAAQ,CAACD,EAAM,IAAI,UAAU,cAAc,GAC7CA,EAAM,IAAI,UAAU,eAAgBC,CAAI,CAE5C,CACA,SAASG,GAAaJ,EAAOK,EAAUC,EAAO,IAAK,CACjDN,EAAM,IAAI,WAAaM,EACvBN,EAAM,IAAI,UAAU,WAAYK,CAAQ,EAExC,MAAME,EAAO,yEADMF,EAAS,QAAQ,KAAM,KAAK,oBAE/C,OAAON,GAAKC,EAAOO,EAAMV,GAAM,IAAI,CACrC,CC/NO,MAAMW,GAAW,IAAMlB,GAAMT,EAAY,EAAC,QAAS,OAAO,EACpD4B,EAAaC,GAAS,CACjC,MAAMnF,EAAMmE,GAAYgB,CAAI,EAC5B,GAAI,CACc7B,IACR,SAAS,YAAatD,CAAG,EACjC,MAAMtB,EAAQuG,KACdvG,EAAM,MAAQA,EAAM,OAASsB,CACjC,MAAI,CACA,MAAMA,CACP,CACD,OAAOA,CACT,EAYamE,GAAenE,GAAQ,CAClC,MAAMmF,EAAOC,GAAapF,CAAG,EAC7B,SAAK,aAAe,GACbmF,CACT,ECzBaE,GAAY,IAAM,OAC7B,OAAOhB,IAAY,IAAZ,cAAc,OACvB,EACaiB,GAAW,IAClB7B,GAAkB,EACb8B,GAAO,SAAUjC,EAAY,EAAC,MAAM,EAEtCA,EAAY,EAAC,OAwBTkC,GAAa,CAACC,EAAIC,IAAY,CACpCD,IACHA,EAAK,KAEP,MAAME,EAAS,OAAOF,GAAO,SAAWA,EAAKA,EAAG,MAAQ,IAClDG,EAAa9J,GAAY6J,EAAQ,EAAI,EAC3C,GAAIC,GAAc,EAACF,WAAS,UAC1B,MAAM,IAAI,MAAM,mGAAmG,EAErH,GAAIE,GAAc1I,GAASyI,CAAM,EAAE,WAAa,UAC9C,MAAM,IAAI,MAAM,iDAAiD,EAKnE,MAAME,EAASR,KACK,CAClB,MAAMrC,EAAUM,IAChB,GAAIN,EAAQ,YAAcA,EAAQ,WAAW,MAAO,CAClD,MAAM8C,EAAmBF,EAAaD,EAAS5I,EAAQ8D,GAAgB,EAAG,IAAI,QAASgF,EAAO,QAAQJ,CAAE,EAAE,UAAY,GAAG,EACzH,OAAOzC,EAAQ,SAAS,gBAAgB,EAAE,KAAK,IAAM6B,GAAa7B,EAAQ,WAAW,MAAO8C,GAAkBJ,iBAAS,eAAgB,GAAG,CAAC,CAC5I,CACF,CACD,OAAIE,GACEF,WAAS,QACX,SAAS,QAAQC,CAAM,EAEvB,SAAS,KAAOA,EAEX,QAAQ,WAEVD,WAAS,QAAUG,EAAO,QAAQJ,CAAE,EAAII,EAAO,KAAKJ,CAAE,CAC/D,wjBCjEAM,iCACAC,yBAcA,eACA,oCAMA,UACA,OACA,OACA,IACA,qBACA,eACA,WACA,EACA,MACA,qBACA,eACA,WACA,EACA,QACA,YACA,eACA,WACA,EACA,KACA,YACA,eACA,WACA,EACA,OACA,aACA,eACA,WACA,EACA,UACA,aACA,eACA,WACA,EACA,YACA,aACA,eACA,WACA,EACA,aACA,YACA,eACA,WACA,EACA,kBACA,YACA,eACA,WACA,EACA,iBACA,YACA,eACA,WACA,EACA,SACA,aACA,eACA,WACA,EACA,kBACA,YACA,eACA,WACA,EACA,UACA,aACA,eACA,WACA,EACA,QACA,aACA,eACA,WACA,CACA,EACA,mBACA,aACAP,QAEAQ,gBACA,EACAL,QACAK,YAGAA,6BACA,GAEA,yBACA,GAEAR,4BACA,EACAS,SAoCA,qBACA,YACA,SACAC,iBACA,CACA,WAGA,WACA,sEACA,yCACA,wDACA,kBACA,oCACA,eACA,EACAC,SACA,EAEA,2GACAC,iBAEAC,8DACAC,gCACA,gBACAH,UAGAA,WACA,OACA,WACA,mBACA,MACA,SACA,YACA,gBACA,GAVA,KAYAI,mEACA,CACA,CACA,EACA,CACAC,+BCrMA,SAASC,EAAS5M,EAAK,CACrB,OAAOA,IAAQ,MAAQ,OAAOA,GAAQ,QACxC,CACA,SAAS6M,GAAMC,EAASC,EAAUC,EAAY,IAAKC,EAAQ,CACzD,GAAI,CAACL,EAASG,CAAQ,EACpB,OAAOF,GAAMC,EAAS,CAAE,EAAEE,EAAWC,CAAM,EAE7C,MAAM3L,EAAM,OAAO,OAAO,CAAE,EAAEyL,CAAQ,EACtC,UAAWlN,KAAOiN,EAAS,CACzB,GAAIjN,IAAQ,aAAeA,IAAQ,cACjC,SAEF,MAAMG,EAAM8M,EAAQjN,GAChBG,GAAQ,OAGRiN,GAAUA,EAAO3L,EAAKzB,EAAKG,EAAKgN,CAAS,IAGzC,MAAM,QAAQhN,CAAG,GAAK,MAAM,QAAQsB,EAAIzB,EAAI,EAC9CyB,EAAIzB,GAAOG,EAAI,OAAOsB,EAAIzB,EAAI,EACrB+M,EAAS5M,CAAG,GAAK4M,EAAStL,EAAIzB,EAAI,EAC3CyB,EAAIzB,GAAOgN,GAAM7M,EAAKsB,EAAIzB,IAAOmN,EAAY,GAAGA,KAAe,IAAMnN,EAAI,SAAQ,EAAIoN,CAAM,EAE3F3L,EAAIzB,GAAOG,GAEd,CACD,OAAOsB,CACT,CACA,SAAS4L,GAAWD,EAAQ,CAC1B,MAAO,IAAI1D,IAASA,EAAK,OAAO,CAAC4D,EAAGC,IAAMP,GAAMM,EAAGC,EAAG,GAAIH,CAAM,EAAG,CAAE,EACvE,CACA,MAAMI,GAAOH,GAAU,EACjBI,GAASJ,GAAW,CAAC5L,EAAKzB,EAAK0N,EAAcC,IAAe,CAChE,GAAI,OAAOlM,EAAIzB,GAAS,KAAe,OAAO0N,GAAiB,WAC7D,SAAI1N,GAAO0N,EAAajM,EAAIzB,EAAI,EACzB,EAEX,CAAC,ECnCK4N,GAAe,CAAE,EAIRH,GAAOG,EAAY,ECiflC,MAAMC,GAAc1N,GAAQ,OAAOA,GAAQ,WCrfpC,SAAS2N,GAAQC,EAAM,CAC5B,MAAMC,EAAeH,GAAWE,CAAI,EAAIE,EAASF,CAAI,EAAIA,EACzDpE,EAAY,EAAC,SAASqE,CAAY,CACpC,CCHA,MAAME,EAAa,CAAE,EAENC,KAAiB9E,GAAW,CACzC,UAAW+E,KAAQF,EACjB7E,EAAQ,OAAO,UAAU+E,EAAMF,EAAWE,EAAK,EAC/C/E,EAAQ,OAAO,UAAU,OAAS+E,EAAMF,EAAWE,EAAK,CAE5D,CAAC,ECED,iBACAC,gBACAC,oBACAC,0BACAC,mBAGAC,aACA,2BACA,8BACA,2BACAC,6BACA,CACA,WACA,2CACA,SAEA1O,eACA0O,gBAEAA,mBAEA,CAEA,QACA,EAGAC,iEACAC,yEACAC,OACA,WACA,kCAIA,GAHA7O,2BAGAC,gBACA,SAEA,YACAA,SACA6O,0BAEAC,SACA,CACA,oCACA,EAGA,iBACA,uDACA,gCACA,gCACA,wBACA,kCACAC,UACAC,6BACA,CACA,CACA,uBACA,CAGA,WACA,oDACA,SAEA,uBACA,cACA,aAEA,mCACA,kBAEA,aACA,gBAEA,oDACA,kBACA,MAMA,GALA,qDACAhP,oBAEAA,OAEAA,WACA,sBAEA,CACA,QACA,EAQAiP,IACA,QACA,OACA,OACA,OACA,QACA,SACA,WACA,YACA,WACA,EACAC,UACAC,QACA,GACA,mBACAA,6BAEAA,QAEAC,OACA,WACAC,iBACA,iBACA,cAEA,UACA,YACAC,sCACA,MACA,oBACA,MACA,WACAA,8CACA,MACA,QACA,mBACA,aACA,iBACAtP,cACAsP,0BACA,GACAtP,GACAsP,uBAEA,CACA,KACA,CAEA,QACA,EACAC,WACA,0BACA,KACA,4BACAxP,QACA0O,qBAIA,WACA,kBACA,aACAzO,UAEAA,OACAyO,qBAEAA,oBAEAY,UACA,CACAA,SACAZ,8BAEAA,oBAEA,EACAe,6BACA,QACA,eACAC,SACA,4CACAC,+BACA,8CACAC,KACAC,KACA,KACA,2BACAF,2DACAE,aAIA,KACA,mGACAC,+DACAF,eAIAG,0BACAA,0BACAA,8BACAC,YAEA,6BACA,4BACA,gCACA,IACAC,eACA,4BACA,aACA,mBACA,qBACA,EAEA,CACA,4BACA,aACA,mBACA,qBACA,EAEA,CACA,QACA,GACAJ,cACA,MACA,oDACA,GACAD,cACA,MACA,oDACA,GACAK,cACAC,YACAR,+CAEAM,2BAEA,GACAD,eACA,UACA,2CACA,CACA,EACAI,OACA,SACAC,UACAC,GACAC,aAEA,SACA,WACAC,kCACAA,eACA,EACA,eACA,WACAC,KACAC,0DACA,yBACApB,SACA,gBACAqB,oBACAD,qBACAC,oBACAD,EACAC,gBACA,GAEA,cACAC,EACAH,OAEAI,SAEA,EACA,GACAA,4BACAA,sCACA,EACA,eACAN,SACA,EACA,kBACAA,oBACA,EACA,6BACA,MACAO,KACAC,KACA,WACA,oCACA,oBACAC,mBACA,QACA,CACA,wBACA,yBACA,QACA,CACA,wBACA,yBACA,QACA,CACAC,sBACAA,gBACA,CACAD,aACAE,WAEAzB,wBACAA,aACA,0CACA,iBACAC,iBAEAW,UACA,mCACA,CACA,EACA,QACA,EAgBAc,MACA,SACAR,eACAS,KACA,qBAEAT,wBACA,8BAEA,kBACA,0BACA,wCAEA,wEACA,EACAU,WACA,YACA,0BACA,8BAEA,cACA,WACA,SACA,WACA,uBACA,GAEAV,kDACA,EAEA,GACA,QACA,SACA,CACA,EACA,gBACA,EACAW,OACA,WACA,SACAR,KACAC,KACAQ,KACA,mCACAZ,gBACAa,OACAb,oBACA,yBACAA,oBACA,yBACAA,aACAY,aAEA/B,aAGA,2DACA,CACA,eACA,mBACA,EACA,gBACA,WACA,KACA,4BACA,EACA,EACA,gBACA,WACA,KACA,4BACA,EACA,EACA,eACA,iBACA,CACA,CACA,ECtaA,eACA,aACAlG,gBAEAA,oCACAmI,QACAxB,aACA,EAEA,GACA3G,eACA,cACAoI,SACA,kBACA,wBACAC,qDAEA3D,kBACA2D,wDAEAlE,aACA,GACAwC,gBAiBA,EAEA3G,6BACA,cACA,OACA,KACA,sBACA,CACA,CAEA,GCnDMsI,GAAwBrF,GAAU,OAAO,YAAY,OAAO,QAAQA,CAAK,EAAE,OAAO,CAAC,EAAGrM,CAAK,IAAMA,IAAU,MAAM,CAAC,EAClH2R,EAAkB,CAACC,EAAaC,IAAgB,CAACxF,EAAOtG,KAC5D8H,GAAQ,IAAM+D,EAAY,CAAE,G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ACA,GACA,wEACA,eACA,GACA,wBACAY,OACAC,4BACA,EACAxM,wBACA6C,kCACA4D,iJACA8F,GAEA,GACA,WACA,uBACA9B,uBAEAzK,cACAA,8BACA,UACA,QACA,EACAiC,KACA,IAEmC,oCAET,qCAC1B,UACA/B,UACA,CACA,sBACA,yCACAuC,iBACAzC,gBACAyC,iDAEAzC,2BACA,iDACA,0BACA,0BACA,OAGA,oBACA,iBACAyM,cAGAA,QAEA,CACA,kBACA,kHACA,MAIA,qDAEA,2BAEA,+BACA,eACA,8CACA,GACA,iBACA,CAEA,aACA,QAEA,CACA,GACA5J,sBAKA,GAJA,+BAIAJ,qBACAvC,WACA,eACA,SACA,6CACA,aACAuC,wCACAzC,0CACA,CACA,wBACAxF,SACA,iBAEA,CACA,GACAwF,yCACA,IACA,iBACA,gBACA,YACA,QACA,EACA,UACAE,UACA,CACA,GACA,oBACA,CAAC,ECvJcJ,IACbgF,GACA4H,GACArC,GACA8B,EACF,ECReQ,IACb,QAASC,GAAqB,IAAMd,cAAO,8BAAgE,0DAAC,KAAKf,GAAKA,EAAE,SAAWA,CAAC,CAAC,CACvI,ECEAnC,GACA,OACA,MACA,6BACA,YACA,CACA,EACA,WACA,aAYA,qBACA,uFACAiE,aAIAtB,yCACA,mBACA,YAMAL,6BAEA,YACA,CACA,CACA,GCpCK,WAAW,SACd,WAAW,OAAS1N,GAAO,OAAO,CAChC,QAASM,GAAS,CACtB,CAAG,GAGa+B,GAAiBC,EAAQ","names":["suspectProtoRx","suspectConstructorRx","JsonSigRx","jsonParseTransform","key","value","destr","val","_lval","HASH_RE","AMPERSAND_RE","EQUAL_RE","PLUS_RE","ENC_BRACKET_OPEN_RE","ENC_BRACKET_CLOSE_RE","ENC_CARET_RE","ENC_BACKTICK_RE","ENC_CURLY_OPEN_RE","ENC_PIPE_RE","ENC_CURLY_CLOSE_RE","ENC_SPACE_RE","encode","text","encodeQueryValue","encodeQueryKey","decode","decodeQueryValue","parseQuery","paramsStr","obj","param","s","encodeQueryItem","_val","stringifyQuery","query","k","PROTOCOL_REGEX","PROTOCOL_RELATIVE_REGEX","hasProtocol","inputStr","acceptProtocolRelative","TRAILING_SLASH_RE","hasTrailingSlash","input","queryParams","withoutTrailingSlash","s0","withTrailingSlash","hasLeadingSlash","withoutLeadingSlash","withLeadingSlash","withBase","base","isEmptyURL","_base","joinURL","withQuery","parsed","parseURL","mergedQuery","stringifyParsedURL","url","isNonEmptyURL","i","isEqual","a","b","opts","defaultProto","parsePath","protocol","auth","hostAndPath","host","path","pathname","search","hash","fullpath","FetchError","createFetchError","request","error","response","message","fetchError","payloadMethods","isPayloadMethod","method","isJSONSerializable","textTypes","JSON_RE","detectResponseType","_contentType","contentType","retryStatusCodes","createFetch","globalOptions","onError","ctx","isAbort","retries","responseCode","$fetchRaw","err","_request","_opts","Headers","fetch","responseType","data","parseFn","$fetch","r","defaultOptions","_globalThis","appConfig","useRuntimeConfig","baseURL","buildAssetsDir","buildAssetsURL","publicAssetsURL","publicBase","createContext","currentInstance","isSingleton","checkConflict","instance","replace","cb","onRestore","onLeave","asyncHandlers","createNamespace","contexts","globalKey","defaultNamespace","getContext","asyncHandlersKey","executeAsync","fn","restores","leaveHandler","restore2","restore","awaitable","e","nuxtAppCtx","NuxtPluginIndicator","normalizePlugins","_plugins","plugin","nuxtApp","defineNuxtPlugin","callWithNuxt","nuxt","setup","args","useNuxtApp","nuxtAppInstance","vm","getCurrentInstance","useState","autoKey","_key","init","state","toRef","initialValue","isRef","H3Error","createError","isError","_a","MIMES","defer","send","event","type","defaultContentType","resolve","sendRedirect","location","code","html","useError","showError","_err","_createError","useRouter","useRoute","inject","navigateTo","to","options","toPath","isExternal","router","redirectLocation","firstNonUndefined","DEFAULT_EXTERNAL_REL_ATTRIBUTE","props","prefetched","resolveComponent","slots","target","rel","navigate","h","defineNuxtLink","isObject","_defu","baseObj","defaults","namespace","merger","createDefu","p","c","defu","defuFn","currentValue","_namespace","inlineConfig","isFunction","useHead","meta","resolvedMeta","computed","components","_nuxt_components_plugin_mjs_KR1HBZs4kY","name","HEAD_COUNT_KEY","HEAD_ATTRS_KEY","SELF_CLOSING_TAGS","BODY_TAG_ATTR_NAME","createElement","el","stringifyAttrName","stringifyAttrValue","stringifyAttrs","attribute","handledAttributes","cloneTag","nonce","acceptFields","renderTemplate","template","headObjToTags","keys","tags","setAttrs","updateElements","body","bodyMetaElements","oldHeadElements","oldBodyElements","_b","headCountEl","head","newElements","t","createHead","previousTags","initHeadObject","allHeadObjs","app","deduping","titleTemplate","tag","dedupeKey","deduped","htmlAttrs","bodyAttrs","title","actualTags","document","tagToString","isBodyTag","sortTags","renderHeadToString","bodyTags","titleTag","watchEffect","headObj","overrides","removeUndefinedProps","setupForUseMeta","metaFactory","renderChild","globalProps","Script","defineComponent","script","NoScript","noscript","textContent","children","Link","link","Base","Title","_","_c","Meta","Style","style","Head","_props","Html","Body","appHead","appLayoutTransition","appPageTransition","appKeepalive","metaMixin","source","node_modules_nuxt_dist_head_runtime_plugin_mjs_1QO0gqa6n2","markRaw","Components","interpolatePath","route","match","generateRouteKey","override","routeProps","matchedRoute","m","wrapInKeepAlive","Fragment","_wrapIf","component","isNestedKey","NuxtPage","isNested","transitionProps","Transition","_d","Component","previousRoute","_routes","C_58_47WIP_32Projects_47RGB_45Lamp_45Display_45Emulator_47pages_47index_46vueMeta","__vitePreload","configRouterOptions","routerOptions","globalMiddleware","namedMiddleware","node_modules_nuxt_dist_pages_runtime_router_mjs_qNv5Ky2ZmB","routerBase","routes","initialURL","syncCurrentRoute","_route","middlewareEntries","node_modules_nuxt_dist_head_runtime_lib_vueuse_head_plugin_mjs_D7WGfuP1A0","layouts","defineAsyncComponent","hasLayout"],"sources":["../../../node_modules/destr/dist/index.mjs","../../../node_modules/ufo/dist/index.mjs","../../../node_modules/ohmyfetch/dist/shared/ohmyfetch.c2a48baf.mjs","../../../node_modules/ohmyfetch/dist/index.mjs","../../../virtual:nuxt:C:/WIP Projects/RGB-Lamp-Display-Emulator/.nuxt/paths.mjs","../../../node_modules/unctx/dist/index.mjs","../../../node_modules/nuxt/dist/app/nuxt.mjs","../../../node_modules/nuxt/dist/app/composables/state.mjs","../../../node_modules/h3/dist/index.mjs","../../../node_modules/nuxt/dist/app/composables/error.mjs","../../../node_modules/nuxt/dist/app/composables/router.mjs","../../../node_modules/nuxt/dist/app/components/nuxt-link.mjs","../../../node_modules/defu/dist/defu.mjs","../../app.config.mjs","../../../node_modules/@vue/shared/dist/shared.esm-bundler.js","../../../node_modules/nuxt/dist/head/runtime/composables.mjs","../../../virtual:nuxt:C:/WIP Projects/RGB-Lamp-Display-Emulator/.nuxt/components.plugin.mjs","../../../node_modules/@vueuse/head/dist/index.mjs","../../../node_modules/nuxt/dist/head/runtime/lib/vueuse-head.plugin.mjs","../../../node_modules/nuxt/dist/head/runtime/components.mjs","../../../virtual:nuxt:C:/WIP Projects/RGB-Lamp-Display-Emulator/.nuxt/nuxt.config.mjs","../../../node_modules/nuxt/dist/head/runtime/plugin.mjs","../../../node_modules/nuxt/dist/pages/runtime/utils.mjs","../../../node_modules/nuxt/dist/app/components/utils.mjs","../../../node_modules/nuxt/dist/pages/runtime/page.mjs","../../../virtual:nuxt:C:/WIP Projects/RGB-Lamp-Display-Emulator/.nuxt/routes.mjs","../../../virtual:nuxt:C:/WIP Projects/RGB-Lamp-Display-Emulator/.nuxt/router.options.mjs","../../../virtual:nuxt:C:/WIP Projects/RGB-Lamp-Display-Emulator/.nuxt/middleware.mjs","../../../node_modules/nuxt/dist/pages/runtime/router.mjs","../../../virtual:nuxt:C:/WIP Projects/RGB-Lamp-Display-Emulator/.nuxt/plugins/server.mjs","../../../virtual:nuxt:C:/WIP Projects/RGB-Lamp-Display-Emulator/.nuxt/layouts.mjs","../../../node_modules/nuxt/dist/app/components/layout.mjs","../../../node_modules/nuxt/dist/app/entry.mjs"],"sourcesContent":["const suspectProtoRx = /\"(?:_|\\\\u005[Ff])(?:_|\\\\u005[Ff])(?:p|\\\\u0070)(?:r|\\\\u0072)(?:o|\\\\u006[Ff])(?:t|\\\\u0074)(?:o|\\\\u006[Ff])(?:_|\\\\u005[Ff])(?:_|\\\\u005[Ff])\"\\s*:/;\nconst suspectConstructorRx = /\"(?:c|\\\\u0063)(?:o|\\\\u006[Ff])(?:n|\\\\u006[Ee])(?:s|\\\\u0073)(?:t|\\\\u0074)(?:r|\\\\u0072)(?:u|\\\\u0075)(?:c|\\\\u0063)(?:t|\\\\u0074)(?:o|\\\\u006[Ff])(?:r|\\\\u0072)\"\\s*:/;\nconst JsonSigRx = /^[\"{[]|^-?[0-9][0-9.]{0,14}$/;\nfunction jsonParseTransform(key, value) {\n  if (key === \"__proto__\" || key === \"constructor\") {\n    return;\n  }\n  return value;\n}\nfunction destr(val) {\n  if (typeof val !== \"string\") {\n    return val;\n  }\n  const _lval = val.toLowerCase();\n  if (_lval === \"true\") {\n    return true;\n  }\n  if (_lval === \"false\") {\n    return false;\n  }\n  if (_lval === \"null\") {\n    return null;\n  }\n  if (_lval === \"nan\") {\n    return NaN;\n  }\n  if (_lval === \"infinity\") {\n    return Infinity;\n  }\n  if (_lval === \"undefined\") {\n    return void 0;\n  }\n  if (!JsonSigRx.test(val)) {\n    return val;\n  }\n  try {\n    if (suspectProtoRx.test(val) || suspectConstructorRx.test(val)) {\n      return JSON.parse(val, jsonParseTransform);\n    }\n    return JSON.parse(val);\n  } catch (_e) {\n    return val;\n  }\n}\n\nexport { destr as default };\n","const n = /[^\\0-\\x7E]/;\nconst t = /[\\x2E\\u3002\\uFF0E\\uFF61]/g;\nconst o = { overflow: \"Overflow Error\", \"not-basic\": \"Illegal Input\", \"invalid-input\": \"Invalid Input\" };\nconst e = Math.floor;\nconst r = String.fromCharCode;\nfunction s(n2) {\n  throw new RangeError(o[n2]);\n}\nconst c = function(n2, t2) {\n  return n2 + 22 + 75 * (n2 < 26) - ((t2 != 0) << 5);\n};\nconst u = function(n2, t2, o2) {\n  let r2 = 0;\n  for (n2 = o2 ? e(n2 / 700) : n2 >> 1, n2 += e(n2 / t2); n2 > 455; r2 += 36) {\n    n2 = e(n2 / 35);\n  }\n  return e(r2 + 36 * n2 / (n2 + 38));\n};\nfunction toASCII(o2) {\n  return function(n2, o3) {\n    const e2 = n2.split(\"@\");\n    let r2 = \"\";\n    e2.length > 1 && (r2 = e2[0] + \"@\", n2 = e2[1]);\n    const s2 = function(n3, t2) {\n      const o4 = [];\n      let e3 = n3.length;\n      for (; e3--; ) {\n        o4[e3] = t2(n3[e3]);\n      }\n      return o4;\n    }((n2 = n2.replace(t, \".\")).split(\".\"), o3).join(\".\");\n    return r2 + s2;\n  }(o2, function(t2) {\n    return n.test(t2) ? \"xn--\" + function(n2) {\n      const t3 = [];\n      const o3 = (n2 = function(n3) {\n        const t4 = [];\n        let o4 = 0;\n        const e2 = n3.length;\n        for (; o4 < e2; ) {\n          const r2 = n3.charCodeAt(o4++);\n          if (r2 >= 55296 && r2 <= 56319 && o4 < e2) {\n            const e3 = n3.charCodeAt(o4++);\n            (64512 & e3) == 56320 ? t4.push(((1023 & r2) << 10) + (1023 & e3) + 65536) : (t4.push(r2), o4--);\n          } else {\n            t4.push(r2);\n          }\n        }\n        return t4;\n      }(n2)).length;\n      let f = 128;\n      let i = 0;\n      let l = 72;\n      for (const o4 of n2) {\n        o4 < 128 && t3.push(r(o4));\n      }\n      const h = t3.length;\n      let p = h;\n      for (h && t3.push(\"-\"); p < o3; ) {\n        let o4 = 2147483647;\n        for (const t4 of n2) {\n          t4 >= f && t4 < o4 && (o4 = t4);\n        }\n        const a = p + 1;\n        o4 - f > e((2147483647 - i) / a) && s(\"overflow\"), i += (o4 - f) * a, f = o4;\n        for (const o5 of n2) {\n          if (o5 < f && ++i > 2147483647 && s(\"overflow\"), o5 == f) {\n            let n3 = i;\n            for (let o6 = 36; ; o6 += 36) {\n              const s2 = o6 <= l ? 1 : o6 >= l + 26 ? 26 : o6 - l;\n              if (n3 < s2) {\n                break;\n              }\n              const u2 = n3 - s2;\n              const f2 = 36 - s2;\n              t3.push(r(c(s2 + u2 % f2, 0))), n3 = e(u2 / f2);\n            }\n            t3.push(r(c(n3, 0))), l = u(i, a, p == h), i = 0, ++p;\n          }\n        }\n        ++i, ++f;\n      }\n      return t3.join(\"\");\n    }(t2) : t2;\n  });\n}\n\nconst HASH_RE = /#/g;\nconst AMPERSAND_RE = /&/g;\nconst SLASH_RE = /\\//g;\nconst EQUAL_RE = /=/g;\nconst IM_RE = /\\?/g;\nconst PLUS_RE = /\\+/g;\nconst ENC_BRACKET_OPEN_RE = /%5B/gi;\nconst ENC_BRACKET_CLOSE_RE = /%5D/gi;\nconst ENC_CARET_RE = /%5E/gi;\nconst ENC_BACKTICK_RE = /%60/gi;\nconst ENC_CURLY_OPEN_RE = /%7B/gi;\nconst ENC_PIPE_RE = /%7C/gi;\nconst ENC_CURLY_CLOSE_RE = /%7D/gi;\nconst ENC_SPACE_RE = /%20/gi;\nconst ENC_SLASH_RE = /%2F/gi;\nconst ENC_ENC_SLASH_RE = /%252F/gi;\nfunction encode(text) {\n  return encodeURI(\"\" + text).replace(ENC_PIPE_RE, \"|\").replace(ENC_BRACKET_OPEN_RE, \"[\").replace(ENC_BRACKET_CLOSE_RE, \"]\");\n}\nfunction encodeHash(text) {\n  return encode(text).replace(ENC_CURLY_OPEN_RE, \"{\").replace(ENC_CURLY_CLOSE_RE, \"}\").replace(ENC_CARET_RE, \"^\");\n}\nfunction encodeQueryValue(text) {\n  return encode(text).replace(PLUS_RE, \"%2B\").replace(ENC_SPACE_RE, \"+\").replace(HASH_RE, \"%23\").replace(AMPERSAND_RE, \"%26\").replace(ENC_BACKTICK_RE, \"`\").replace(ENC_CURLY_OPEN_RE, \"{\").replace(ENC_CURLY_CLOSE_RE, \"}\").replace(ENC_CARET_RE, \"^\");\n}\nfunction encodeQueryKey(text) {\n  return encodeQueryValue(text).replace(EQUAL_RE, \"%3D\");\n}\nfunction encodePath(text) {\n  return encode(text).replace(HASH_RE, \"%23\").replace(IM_RE, \"%3F\").replace(ENC_ENC_SLASH_RE, \"%2F\").replace(AMPERSAND_RE, \"%26\").replace(PLUS_RE, \"%2B\");\n}\nfunction encodeParam(text) {\n  return encodePath(text).replace(SLASH_RE, \"%2F\");\n}\nfunction decode(text = \"\") {\n  try {\n    return decodeURIComponent(\"\" + text);\n  } catch (_err) {\n    return \"\" + text;\n  }\n}\nfunction decodePath(text) {\n  return decode(text.replace(ENC_SLASH_RE, \"%252F\"));\n}\nfunction decodeQueryValue(text) {\n  return decode(text.replace(PLUS_RE, \" \"));\n}\nfunction encodeHost(name = \"\") {\n  return toASCII(name);\n}\n\nfunction parseQuery(paramsStr = \"\") {\n  const obj = {};\n  if (paramsStr[0] === \"?\") {\n    paramsStr = paramsStr.substr(1);\n  }\n  for (const param of paramsStr.split(\"&\")) {\n    const s = param.match(/([^=]+)=?(.*)/) || [];\n    if (s.length < 2) {\n      continue;\n    }\n    const key = decode(s[1]);\n    if (key === \"__proto__\" || key === \"constructor\") {\n      continue;\n    }\n    const value = decodeQueryValue(s[2] || \"\");\n    if (obj[key]) {\n      if (Array.isArray(obj[key])) {\n        obj[key].push(value);\n      } else {\n        obj[key] = [obj[key], value];\n      }\n    } else {\n      obj[key] = value;\n    }\n  }\n  return obj;\n}\nfunction encodeQueryItem(key, val) {\n  if (typeof val === \"number\" || typeof val === \"boolean\") {\n    val = String(val);\n  }\n  if (!val) {\n    return encodeQueryKey(key);\n  }\n  if (Array.isArray(val)) {\n    return val.map((_val) => `${encodeQueryKey(key)}=${encodeQueryValue(_val)}`).join(\"&\");\n  }\n  return `${encodeQueryKey(key)}=${encodeQueryValue(val)}`;\n}\nfunction stringifyQuery(query) {\n  return Object.keys(query).map((k) => encodeQueryItem(k, query[k])).join(\"&\");\n}\n\nclass $URL {\n  constructor(input = \"\") {\n    this.query = {};\n    if (typeof input !== \"string\") {\n      throw new TypeError(`URL input should be string received ${typeof input} (${input})`);\n    }\n    const parsed = parseURL(input);\n    this.protocol = decode(parsed.protocol);\n    this.host = decode(parsed.host);\n    this.auth = decode(parsed.auth);\n    this.pathname = decodePath(parsed.pathname);\n    this.query = parseQuery(parsed.search);\n    this.hash = decode(parsed.hash);\n  }\n  get hostname() {\n    return parseHost(this.host).hostname;\n  }\n  get port() {\n    return parseHost(this.host).port || \"\";\n  }\n  get username() {\n    return parseAuth(this.auth).username;\n  }\n  get password() {\n    return parseAuth(this.auth).password || \"\";\n  }\n  get hasProtocol() {\n    return this.protocol.length;\n  }\n  get isAbsolute() {\n    return this.hasProtocol || this.pathname[0] === \"/\";\n  }\n  get search() {\n    const q = stringifyQuery(this.query);\n    return q.length ? \"?\" + q : \"\";\n  }\n  get searchParams() {\n    const p = new URLSearchParams();\n    for (const name in this.query) {\n      const value = this.query[name];\n      if (Array.isArray(value)) {\n        value.forEach((v) => p.append(name, v));\n      } else {\n        p.append(name, value || \"\");\n      }\n    }\n    return p;\n  }\n  get origin() {\n    return (this.protocol ? this.protocol + \"//\" : \"\") + encodeHost(this.host);\n  }\n  get fullpath() {\n    return encodePath(this.pathname) + this.search + encodeHash(this.hash);\n  }\n  get encodedAuth() {\n    if (!this.auth) {\n      return \"\";\n    }\n    const { username, password } = parseAuth(this.auth);\n    return encodeURIComponent(username) + (password ? \":\" + encodeURIComponent(password) : \"\");\n  }\n  get href() {\n    const auth = this.encodedAuth;\n    const originWithAuth = (this.protocol ? this.protocol + \"//\" : \"\") + (auth ? auth + \"@\" : \"\") + encodeHost(this.host);\n    return this.hasProtocol && this.isAbsolute ? originWithAuth + this.fullpath : this.fullpath;\n  }\n  append(url) {\n    if (url.hasProtocol) {\n      throw new Error(\"Cannot append a URL with protocol\");\n    }\n    Object.assign(this.query, url.query);\n    if (url.pathname) {\n      this.pathname = withTrailingSlash(this.pathname) + withoutLeadingSlash(url.pathname);\n    }\n    if (url.hash) {\n      this.hash = url.hash;\n    }\n  }\n  toJSON() {\n    return this.href;\n  }\n  toString() {\n    return this.href;\n  }\n}\n\nfunction isRelative(inputStr) {\n  return [\"./\", \"../\"].some((str) => inputStr.startsWith(str));\n}\nconst PROTOCOL_REGEX = /^\\w+:(\\/\\/)?/;\nconst PROTOCOL_RELATIVE_REGEX = /^\\/\\/[^/]+/;\nfunction hasProtocol(inputStr, acceptProtocolRelative = false) {\n  return PROTOCOL_REGEX.test(inputStr) || acceptProtocolRelative && PROTOCOL_RELATIVE_REGEX.test(inputStr);\n}\nconst TRAILING_SLASH_RE = /\\/$|\\/\\?/;\nfunction hasTrailingSlash(input = \"\", queryParams = false) {\n  if (!queryParams) {\n    return input.endsWith(\"/\");\n  }\n  return TRAILING_SLASH_RE.test(input);\n}\nfunction withoutTrailingSlash(input = \"\", queryParams = false) {\n  if (!queryParams) {\n    return (hasTrailingSlash(input) ? input.slice(0, -1) : input) || \"/\";\n  }\n  if (!hasTrailingSlash(input, true)) {\n    return input || \"/\";\n  }\n  const [s0, ...s] = input.split(\"?\");\n  return (s0.slice(0, -1) || \"/\") + (s.length ? `?${s.join(\"?\")}` : \"\");\n}\nfunction withTrailingSlash(input = \"\", queryParams = false) {\n  if (!queryParams) {\n    return input.endsWith(\"/\") ? input : input + \"/\";\n  }\n  if (hasTrailingSlash(input, true)) {\n    return input || \"/\";\n  }\n  const [s0, ...s] = input.split(\"?\");\n  return s0 + \"/\" + (s.length ? `?${s.join(\"?\")}` : \"\");\n}\nfunction hasLeadingSlash(input = \"\") {\n  return input.startsWith(\"/\");\n}\nfunction withoutLeadingSlash(input = \"\") {\n  return (hasLeadingSlash(input) ? input.substr(1) : input) || \"/\";\n}\nfunction withLeadingSlash(input = \"\") {\n  return hasLeadingSlash(input) ? input : \"/\" + input;\n}\nfunction cleanDoubleSlashes(input = \"\") {\n  return input.split(\"://\").map((str) => str.replace(/\\/{2,}/g, \"/\")).join(\"://\");\n}\nfunction withBase(input, base) {\n  if (isEmptyURL(base)) {\n    return input;\n  }\n  const _base = withoutTrailingSlash(base);\n  if (input.startsWith(_base)) {\n    return input;\n  }\n  return joinURL(_base, input);\n}\nfunction withoutBase(input, base) {\n  if (isEmptyURL(base)) {\n    return input;\n  }\n  const _base = withoutTrailingSlash(base);\n  if (!input.startsWith(_base)) {\n    return input;\n  }\n  const trimmed = input.substring(_base.length);\n  return trimmed[0] === \"/\" ? trimmed : \"/\" + trimmed;\n}\nfunction withQuery(input, query) {\n  const parsed = parseURL(input);\n  const mergedQuery = { ...parseQuery(parsed.search), ...query };\n  parsed.search = stringifyQuery(mergedQuery);\n  return stringifyParsedURL(parsed);\n}\nfunction getQuery(input) {\n  return parseQuery(parseURL(input).search);\n}\nfunction isEmptyURL(url) {\n  return !url || url === \"/\";\n}\nfunction isNonEmptyURL(url) {\n  return url && url !== \"/\";\n}\nfunction joinURL(base, ...input) {\n  let url = base || \"\";\n  for (const i of input.filter(isNonEmptyURL)) {\n    url = url ? withTrailingSlash(url) + withoutLeadingSlash(i) : i;\n  }\n  return url;\n}\nfunction withHttp(input) {\n  return withProtocol(input, \"http://\");\n}\nfunction withHttps(input) {\n  return withProtocol(input, \"https://\");\n}\nfunction withoutProtocol(input) {\n  return withProtocol(input, \"\");\n}\nfunction withProtocol(input, protocol) {\n  const match = input.match(PROTOCOL_REGEX);\n  if (!match) {\n    return protocol + input;\n  }\n  return protocol + input.substring(match[0].length);\n}\nfunction createURL(input) {\n  return new $URL(input);\n}\nfunction normalizeURL(input) {\n  return createURL(input).toString();\n}\nfunction resolveURL(base, ...input) {\n  const url = createURL(base);\n  for (const i of input.filter(isNonEmptyURL)) {\n    url.append(createURL(i));\n  }\n  return url.toString();\n}\nfunction isSamePath(p1, p2) {\n  return decode(withoutTrailingSlash(p1)) === decode(withoutTrailingSlash(p2));\n}\nfunction isEqual(a, b, opts = {}) {\n  if (!opts.trailingSlash) {\n    a = withTrailingSlash(a);\n    b = withTrailingSlash(b);\n  }\n  if (!opts.leadingSlash) {\n    a = withLeadingSlash(a);\n    b = withLeadingSlash(b);\n  }\n  if (!opts.encoding) {\n    a = decode(a);\n    b = decode(b);\n  }\n  return a === b;\n}\n\nfunction parseURL(input = \"\", defaultProto) {\n  if (!hasProtocol(input, true)) {\n    return defaultProto ? parseURL(defaultProto + input) : parsePath(input);\n  }\n  const [protocol = \"\", auth, hostAndPath = \"\"] = (input.replace(/\\\\/g, \"/\").match(/([^:/]+:)?\\/\\/([^/@]+@)?(.*)/) || []).splice(1);\n  const [host = \"\", path = \"\"] = (hostAndPath.match(/([^/?#]*)(.*)?/) || []).splice(1);\n  const { pathname, search, hash } = parsePath(path);\n  return {\n    protocol,\n    auth: auth ? auth.substr(0, auth.length - 1) : \"\",\n    host,\n    pathname,\n    search,\n    hash\n  };\n}\nfunction parsePath(input = \"\") {\n  const [pathname = \"\", search = \"\", hash = \"\"] = (input.match(/([^#?]*)(\\?[^#]*)?(#.*)?/) || []).splice(1);\n  return {\n    pathname,\n    search,\n    hash\n  };\n}\nfunction parseAuth(input = \"\") {\n  const [username, password] = input.split(\":\");\n  return {\n    username: decode(username),\n    password: decode(password)\n  };\n}\nfunction parseHost(input = \"\") {\n  const [hostname, port] = (input.match(/([^/]*)(:0-9+)?/) || []).splice(1);\n  return {\n    hostname: decode(hostname),\n    port\n  };\n}\nfunction stringifyParsedURL(parsed) {\n  const fullpath = parsed.pathname + (parsed.search ? (parsed.search.startsWith(\"?\") ? \"\" : \"?\") + parsed.search : \"\") + parsed.hash;\n  if (!parsed.protocol) {\n    return fullpath;\n  }\n  return parsed.protocol + \"//\" + (parsed.auth ? parsed.auth + \"@\" : \"\") + parsed.host + fullpath;\n}\n\nexport { $URL, cleanDoubleSlashes, createURL, decode, decodePath, decodeQueryValue, encode, encodeHash, encodeHost, encodeParam, encodePath, encodeQueryItem, encodeQueryKey, encodeQueryValue, getQuery, hasLeadingSlash, hasProtocol, hasTrailingSlash, isEmptyURL, isEqual, isNonEmptyURL, isRelative, isSamePath, joinURL, normalizeURL, parseAuth, parseHost, parsePath, parseQuery, parseURL, resolveURL, stringifyParsedURL, stringifyQuery, withBase, withHttp, withHttps, withLeadingSlash, withProtocol, withQuery, withTrailingSlash, withoutBase, withoutLeadingSlash, withoutProtocol, withoutTrailingSlash };\n","import destr from 'destr';\nimport { withBase, withQuery } from 'ufo';\n\nclass FetchError extends Error {\n  constructor() {\n    super(...arguments);\n    this.name = \"FetchError\";\n  }\n}\nfunction createFetchError(request, error, response) {\n  let message = \"\";\n  if (request && response) {\n    message = `${response.status} ${response.statusText} (${request.toString()})`;\n  }\n  if (error) {\n    message = `${error.message} (${message})`;\n  }\n  const fetchError = new FetchError(message);\n  Object.defineProperty(fetchError, \"request\", { get() {\n    return request;\n  } });\n  Object.defineProperty(fetchError, \"response\", { get() {\n    return response;\n  } });\n  Object.defineProperty(fetchError, \"data\", { get() {\n    return response && response._data;\n  } });\n  return fetchError;\n}\n\nconst payloadMethods = new Set(Object.freeze([\"PATCH\", \"POST\", \"PUT\", \"DELETE\"]));\nfunction isPayloadMethod(method = \"GET\") {\n  return payloadMethods.has(method.toUpperCase());\n}\nfunction isJSONSerializable(val) {\n  if (val === void 0) {\n    return false;\n  }\n  const t = typeof val;\n  if (t === \"string\" || t === \"number\" || t === \"boolean\" || t === null) {\n    return true;\n  }\n  if (t !== \"object\") {\n    return false;\n  }\n  if (Array.isArray(val)) {\n    return true;\n  }\n  return val.constructor && val.constructor.name === \"Object\" || typeof val.toJSON === \"function\";\n}\nconst textTypes = /* @__PURE__ */ new Set([\n  \"image/svg\",\n  \"application/xml\",\n  \"application/xhtml\",\n  \"application/html\"\n]);\nconst JSON_RE = /^application\\/(?:[\\w!#$%&*`\\-.^~]*\\+)?json(;.+)?$/i;\nfunction detectResponseType(_contentType = \"\") {\n  if (!_contentType) {\n    return \"json\";\n  }\n  const contentType = _contentType.split(\";\").shift();\n  if (JSON_RE.test(contentType)) {\n    return \"json\";\n  }\n  if (textTypes.has(contentType) || contentType.startsWith(\"text/\")) {\n    return \"text\";\n  }\n  return \"blob\";\n}\n\nconst retryStatusCodes = /* @__PURE__ */ new Set([\n  408,\n  409,\n  425,\n  429,\n  500,\n  502,\n  503,\n  504\n]);\nfunction createFetch(globalOptions) {\n  const { fetch, Headers } = globalOptions;\n  function onError(ctx) {\n    const isAbort = ctx.error && ctx.error.name === \"AbortError\" || false;\n    if (ctx.options.retry !== false && !isAbort) {\n      const retries = typeof ctx.options.retry === \"number\" ? ctx.options.retry : isPayloadMethod(ctx.options.method) ? 0 : 1;\n      const responseCode = ctx.response && ctx.response.status || 500;\n      if (retries > 0 && retryStatusCodes.has(responseCode)) {\n        return $fetchRaw(ctx.request, {\n          ...ctx.options,\n          retry: retries - 1\n        });\n      }\n    }\n    const err = createFetchError(ctx.request, ctx.error, ctx.response);\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(err, $fetchRaw);\n    }\n    throw err;\n  }\n  const $fetchRaw = async function $fetchRaw2(_request, _opts = {}) {\n    const ctx = {\n      request: _request,\n      options: { ...globalOptions.defaults, ..._opts },\n      response: void 0,\n      error: void 0\n    };\n    if (ctx.options.onRequest) {\n      await ctx.options.onRequest(ctx);\n    }\n    if (typeof ctx.request === \"string\") {\n      if (ctx.options.baseURL) {\n        ctx.request = withBase(ctx.request, ctx.options.baseURL);\n      }\n      if (ctx.options.query || ctx.options.params) {\n        ctx.request = withQuery(ctx.request, { ...ctx.options.params, ...ctx.options.query });\n      }\n      if (ctx.options.body && isPayloadMethod(ctx.options.method)) {\n        if (isJSONSerializable(ctx.options.body)) {\n          ctx.options.body = typeof ctx.options.body === \"string\" ? ctx.options.body : JSON.stringify(ctx.options.body);\n          ctx.options.headers = new Headers(ctx.options.headers);\n          if (!ctx.options.headers.has(\"content-type\")) {\n            ctx.options.headers.set(\"content-type\", \"application/json\");\n          }\n          if (!ctx.options.headers.has(\"accept\")) {\n            ctx.options.headers.set(\"accept\", \"application/json\");\n          }\n        }\n      }\n    }\n    ctx.response = await fetch(ctx.request, ctx.options).catch(async (error) => {\n      ctx.error = error;\n      if (ctx.options.onRequestError) {\n        await ctx.options.onRequestError(ctx);\n      }\n      return onError(ctx);\n    });\n    const responseType = (ctx.options.parseResponse ? \"json\" : ctx.options.responseType) || detectResponseType(ctx.response.headers.get(\"content-type\") || \"\");\n    if (responseType === \"json\") {\n      const data = await ctx.response.text();\n      const parseFn = ctx.options.parseResponse || destr;\n      ctx.response._data = parseFn(data);\n    } else if (responseType === \"stream\") {\n      ctx.response._data = ctx.response.body;\n    } else {\n      ctx.response._data = await ctx.response[responseType]();\n    }\n    if (ctx.options.onResponse) {\n      await ctx.options.onResponse(ctx);\n    }\n    if (!ctx.response.ok) {\n      if (ctx.options.onResponseError) {\n        await ctx.options.onResponseError(ctx);\n      }\n    }\n    return ctx.response.ok ? ctx.response : onError(ctx);\n  };\n  const $fetch = function $fetch2(request, opts) {\n    return $fetchRaw(request, opts).then((r) => r._data);\n  };\n  $fetch.raw = $fetchRaw;\n  $fetch.create = (defaultOptions = {}) => createFetch({\n    ...globalOptions,\n    defaults: {\n      ...globalOptions.defaults,\n      ...defaultOptions\n    }\n  });\n  return $fetch;\n}\n\nexport { FetchError as F, createFetchError as a, createFetch as c };\n","import { c as createFetch } from './shared/ohmyfetch.c2a48baf.mjs';\nexport { F as FetchError, c as createFetch, a as createFetchError } from './shared/ohmyfetch.c2a48baf.mjs';\nimport 'destr';\nimport 'ufo';\n\nconst _globalThis = function() {\n  if (typeof globalThis !== \"undefined\") {\n    return globalThis;\n  }\n  if (typeof self !== \"undefined\") {\n    return self;\n  }\n  if (typeof window !== \"undefined\") {\n    return window;\n  }\n  if (typeof global !== \"undefined\") {\n    return global;\n  }\n  throw new Error(\"unable to locate global object\");\n}();\nconst fetch = _globalThis.fetch || (() => Promise.reject(new Error(\"[ohmyfetch] global.fetch is not supported!\")));\nconst Headers = _globalThis.Headers;\nconst $fetch = createFetch({ fetch, Headers });\n\nexport { $fetch, Headers, fetch };\n","import { joinURL } from 'ufo'\nimport { useRuntimeConfig } from '#internal/nitro'\nconst appConfig = useRuntimeConfig().app\nexport const baseURL = () => appConfig.baseURL\nexport const buildAssetsDir = () => appConfig.buildAssetsDir\nexport const buildAssetsURL = (...path) => joinURL(publicAssetsURL(), buildAssetsDir(), ...path)\nexport const publicAssetsURL = (...path) => {\n  const publicBase = appConfig.cdnURL || appConfig.baseURL\n  return path.length ? joinURL(publicBase, ...path) : publicBase\n}\nglobalThis.__buildAssetsURL = buildAssetsURL\nglobalThis.__publicAssetsURL = publicAssetsURL","function createContext() {\n  let currentInstance = null;\n  let isSingleton = false;\n  const checkConflict = (instance) => {\n    if (currentInstance && currentInstance !== instance) {\n      throw new Error(\"Context conflict\");\n    }\n  };\n  return {\n    use: () => {\n      if (currentInstance == null) {\n        throw new Error(\"Context is not available\");\n      }\n      return currentInstance;\n    },\n    tryUse: () => {\n      return currentInstance;\n    },\n    set: (instance, replace) => {\n      if (!replace) {\n        checkConflict(instance);\n      }\n      currentInstance = instance;\n      isSingleton = true;\n    },\n    unset: () => {\n      currentInstance = null;\n      isSingleton = false;\n    },\n    call: (instance, cb) => {\n      checkConflict(instance);\n      currentInstance = instance;\n      try {\n        return cb();\n      } finally {\n        if (!isSingleton) {\n          currentInstance = null;\n        }\n      }\n    },\n    async callAsync(instance, cb) {\n      currentInstance = instance;\n      const onRestore = () => {\n        currentInstance = instance;\n      };\n      const onLeave = () => currentInstance === instance ? onRestore : void 0;\n      asyncHandlers.add(onLeave);\n      try {\n        const r = cb();\n        if (!isSingleton) {\n          currentInstance = null;\n        }\n        return await r;\n      } finally {\n        asyncHandlers.delete(onLeave);\n      }\n    }\n  };\n}\nfunction createNamespace() {\n  const contexts = {};\n  return {\n    get(key) {\n      if (!contexts[key]) {\n        contexts[key] = createContext();\n      }\n      contexts[key];\n      return contexts[key];\n    }\n  };\n}\nconst _globalThis = typeof globalThis !== \"undefined\" ? globalThis : typeof self !== \"undefined\" ? self : typeof global !== \"undefined\" ? global : typeof window !== \"undefined\" ? window : {};\nconst globalKey = \"__unctx__\";\nconst defaultNamespace = _globalThis[globalKey] || (_globalThis[globalKey] = createNamespace());\nconst getContext = (key) => defaultNamespace.get(key);\nconst useContext = (key) => getContext(key).use;\nconst asyncHandlersKey = \"__unctx_async_handlers__\";\nconst asyncHandlers = _globalThis[asyncHandlersKey] || (_globalThis[asyncHandlersKey] = /* @__PURE__ */ new Set());\nfunction executeAsync(fn) {\n  const restores = [];\n  for (const leaveHandler of asyncHandlers) {\n    const restore2 = leaveHandler();\n    if (restore2) {\n      restores.push(restore2);\n    }\n  }\n  const restore = () => {\n    for (const restore2 of restores) {\n      restore2();\n    }\n  };\n  let awaitable = fn();\n  if (\"catch\" in awaitable) {\n    awaitable = awaitable.catch((e) => {\n      restore();\n      throw e;\n    });\n  }\n  return [awaitable, restore];\n}\nfunction withAsyncContext(fn, transformed) {\n  if (!transformed) {\n    console.warn(\"[unctx] `withAsyncContext` needs transformation for async context support in\", fn, \"\\n\", fn.toString());\n  }\n  return fn;\n}\n\nexport { createContext, createNamespace, defaultNamespace, executeAsync, getContext, useContext, withAsyncContext };\n","import { getCurrentInstance, reactive } from \"vue\";\nimport { createHooks } from \"hookable\";\nimport { getContext } from \"unctx\";\nconst nuxtAppCtx = getContext(\"nuxt-app\");\nexport const NuxtPluginIndicator = \"__nuxt_plugin\";\nexport function createNuxtApp(options) {\n  const nuxtApp = {\n    provide: void 0,\n    globalName: \"nuxt\",\n    payload: reactive({\n      data: {},\n      state: {},\n      _errors: {},\n      ...process.client ? window.__NUXT__ : { serverRendered: true }\n    }),\n    isHydrating: process.client,\n    _asyncDataPromises: {},\n    _asyncData: {},\n    ...options\n  };\n  nuxtApp.hooks = createHooks();\n  nuxtApp.hook = nuxtApp.hooks.hook;\n  nuxtApp.callHook = nuxtApp.hooks.callHook;\n  nuxtApp.provide = (name, value) => {\n    const $name = \"$\" + name;\n    defineGetter(nuxtApp, $name, value);\n    defineGetter(nuxtApp.vueApp.config.globalProperties, $name, value);\n  };\n  defineGetter(nuxtApp.vueApp, \"$nuxt\", nuxtApp);\n  defineGetter(nuxtApp.vueApp.config.globalProperties, \"$nuxt\", nuxtApp);\n  if (process.server) {\n    if (nuxtApp.ssrContext) {\n      nuxtApp.ssrContext.nuxt = nuxtApp;\n    }\n    nuxtApp.ssrContext = nuxtApp.ssrContext || {};\n    if (nuxtApp.ssrContext.payload) {\n      Object.assign(nuxtApp.payload, nuxtApp.ssrContext.payload);\n    }\n    nuxtApp.ssrContext.payload = nuxtApp.payload;\n    nuxtApp.payload.config = {\n      public: options.ssrContext.runtimeConfig.public,\n      app: options.ssrContext.runtimeConfig.app\n    };\n  }\n  const runtimeConfig = process.server ? options.ssrContext.runtimeConfig : reactive(nuxtApp.payload.config);\n  const compatibilityConfig = new Proxy(runtimeConfig, {\n    get(target, prop) {\n      if (prop === \"public\") {\n        return target.public;\n      }\n      return target[prop] ?? target.public[prop];\n    },\n    set(target, prop, value) {\n      if (process.server || prop === \"public\" || prop === \"app\") {\n        return false;\n      }\n      target[prop] = value;\n      target.public[prop] = value;\n      return true;\n    }\n  });\n  nuxtApp.provide(\"config\", compatibilityConfig);\n  return nuxtApp;\n}\nexport async function applyPlugin(nuxtApp, plugin) {\n  if (typeof plugin !== \"function\") {\n    return;\n  }\n  const { provide } = await callWithNuxt(nuxtApp, plugin, [nuxtApp]) || {};\n  if (provide && typeof provide === \"object\") {\n    for (const key in provide) {\n      nuxtApp.provide(key, provide[key]);\n    }\n  }\n}\nexport async function applyPlugins(nuxtApp, plugins) {\n  for (const plugin of plugins) {\n    await applyPlugin(nuxtApp, plugin);\n  }\n}\nexport function normalizePlugins(_plugins) {\n  const unwrappedPlugins = [];\n  const legacyInjectPlugins = [];\n  const invalidPlugins = [];\n  const plugins = _plugins.map((plugin) => {\n    if (typeof plugin !== \"function\") {\n      invalidPlugins.push(plugin);\n      return null;\n    }\n    if (plugin.length > 1) {\n      legacyInjectPlugins.push(plugin);\n      return (nuxtApp) => plugin(nuxtApp, nuxtApp.provide);\n    }\n    if (!isNuxtPlugin(plugin)) {\n      unwrappedPlugins.push(plugin);\n    }\n    return plugin;\n  }).filter(Boolean);\n  if (process.dev && legacyInjectPlugins.length) {\n    console.warn(\"[warn] [nuxt] You are using a plugin with legacy Nuxt 2 format (context, inject) which is likely to be broken. In the future they will be ignored:\", legacyInjectPlugins.map((p) => p.name || p).join(\",\"));\n  }\n  if (process.dev && invalidPlugins.length) {\n    console.warn(\"[warn] [nuxt] Some plugins are not exposing a function and skipped:\", invalidPlugins);\n  }\n  if (process.dev && unwrappedPlugins.length) {\n    console.warn(\"[warn] [nuxt] You are using a plugin that has not been wrapped in `defineNuxtPlugin`. It is advised to wrap your plugins as in the future this may enable enhancements:\", unwrappedPlugins.map((p) => p.name || p).join(\",\"));\n  }\n  return plugins;\n}\nexport function defineNuxtPlugin(plugin) {\n  plugin[NuxtPluginIndicator] = true;\n  return plugin;\n}\nexport function isNuxtPlugin(plugin) {\n  return typeof plugin === \"function\" && NuxtPluginIndicator in plugin;\n}\nexport function callWithNuxt(nuxt, setup, args) {\n  const fn = () => args ? setup(...args) : setup();\n  if (process.server) {\n    return nuxtAppCtx.callAsync(nuxt, fn);\n  } else {\n    nuxtAppCtx.set(nuxt);\n    return fn();\n  }\n}\nexport function useNuxtApp() {\n  const nuxtAppInstance = nuxtAppCtx.tryUse();\n  if (!nuxtAppInstance) {\n    const vm = getCurrentInstance();\n    if (!vm) {\n      throw new Error(\"nuxt instance unavailable\");\n    }\n    return vm.appContext.app.$nuxt;\n  }\n  return nuxtAppInstance;\n}\nexport function useRuntimeConfig() {\n  return useNuxtApp().$config;\n}\nfunction defineGetter(obj, key, val) {\n  Object.defineProperty(obj, key, { get: () => val });\n}\nexport function defineAppConfig(config) {\n  return config;\n}\n","import { isRef, toRef } from \"vue\";\nimport { useNuxtApp } from \"../nuxt.mjs\";\nexport function useState(...args) {\n  const autoKey = typeof args[args.length - 1] === \"string\" ? args.pop() : void 0;\n  if (typeof args[0] !== \"string\") {\n    args.unshift(autoKey);\n  }\n  const [_key, init] = args;\n  if (!_key || typeof _key !== \"string\") {\n    throw new TypeError(\"[nuxt] [useState] key must be a string: \" + _key);\n  }\n  if (init !== void 0 && typeof init !== \"function\") {\n    throw new Error(\"[nuxt] [useState] init must be a function: \" + init);\n  }\n  const key = \"$s\" + _key;\n  const nuxt = useNuxtApp();\n  const state = toRef(nuxt.payload.state, key);\n  if (state.value === void 0 && init) {\n    const initialValue = init();\n    if (isRef(initialValue)) {\n      nuxt.payload.state[key] = initialValue;\n      return initialValue;\n    }\n    state.value = initialValue;\n  }\n  return state;\n}\n","import { getQuery as getQuery$1, withoutTrailingSlash, withoutBase } from 'ufo';\nimport destr from 'destr';\nimport { parse, serialize } from 'cookie-es';\nimport { createRouter as createRouter$1 } from 'radix3';\n\nclass H3Error extends Error {\n  constructor() {\n    super(...arguments);\n    this.statusCode = 500;\n    this.fatal = false;\n    this.unhandled = false;\n    this.statusMessage = \"Internal Server Error\";\n  }\n}\nH3Error.__h3_error__ = true;\nfunction createError(input) {\n  if (typeof input === \"string\") {\n    return new H3Error(input);\n  }\n  if (isError(input)) {\n    return input;\n  }\n  const err = new H3Error(input.message ?? input.statusMessage, input.cause ? { cause: input.cause } : void 0);\n  if (\"stack\" in input) {\n    try {\n      Object.defineProperty(err, \"stack\", { get() {\n        return input.stack;\n      } });\n    } catch {\n      try {\n        err.stack = input.stack;\n      } catch {\n      }\n    }\n  }\n  if (input.statusCode) {\n    err.statusCode = input.statusCode;\n  }\n  if (input.statusMessage) {\n    err.statusMessage = input.statusMessage;\n  }\n  if (input.data) {\n    err.data = input.data;\n  }\n  if (input.fatal !== void 0) {\n    err.fatal = input.fatal;\n  }\n  if (input.unhandled !== void 0) {\n    err.unhandled = input.unhandled;\n  }\n  return err;\n}\nfunction sendError(event, error, debug) {\n  if (event.res.writableEnded) {\n    return;\n  }\n  const h3Error = isError(error) ? error : createError(error);\n  const responseBody = {\n    statusCode: h3Error.statusCode,\n    statusMessage: h3Error.statusMessage,\n    stack: [],\n    data: h3Error.data\n  };\n  if (debug) {\n    responseBody.stack = (h3Error.stack || \"\").split(\"\\n\").map((l) => l.trim());\n  }\n  if (event.res.writableEnded) {\n    return;\n  }\n  event.res.statusCode = h3Error.statusCode;\n  event.res.statusMessage = h3Error.statusMessage;\n  event.res.setHeader(\"Content-Type\", MIMES.json);\n  event.res.end(JSON.stringify(responseBody, null, 2));\n}\nfunction isError(input) {\n  return input?.constructor?.__h3_error__ === true;\n}\n\nfunction getQuery(event) {\n  return getQuery$1(event.req.url || \"\");\n}\nconst useQuery = getQuery;\nfunction getRouterParams(event) {\n  return event.context.params || {};\n}\nfunction getRouterParam(event, name) {\n  const params = getRouterParams(event);\n  return params[name];\n}\nfunction getMethod(event, defaultMethod = \"GET\") {\n  return (event.req.method || defaultMethod).toUpperCase();\n}\nconst useMethod = getMethod;\nfunction isMethod(event, expected, allowHead) {\n  const method = getMethod(event);\n  if (allowHead && method === \"HEAD\") {\n    return true;\n  }\n  if (typeof expected === \"string\") {\n    if (method === expected) {\n      return true;\n    }\n  } else if (expected.includes(method)) {\n    return true;\n  }\n  return false;\n}\nfunction assertMethod(event, expected, allowHead) {\n  if (!isMethod(event, expected, allowHead)) {\n    throw createError({\n      statusCode: 405,\n      statusMessage: \"HTTP method is not allowed.\"\n    });\n  }\n}\nfunction getRequestHeaders(event) {\n  return event.req.headers;\n}\nconst getHeaders = getRequestHeaders;\nfunction getRequestHeader(event, name) {\n  const headers = getRequestHeaders(event);\n  const value = headers[name.toLowerCase()];\n  return value;\n}\nconst getHeader = getRequestHeader;\n\nconst RawBodySymbol = Symbol.for(\"h3RawBody\");\nconst ParsedBodySymbol = Symbol.for(\"h3ParsedBody\");\nconst PayloadMethods = [\"PATCH\", \"POST\", \"PUT\", \"DELETE\"];\nfunction readRawBody(event, encoding = \"utf-8\") {\n  assertMethod(event, PayloadMethods);\n  if (RawBodySymbol in event.req) {\n    const promise2 = Promise.resolve(event.req[RawBodySymbol]);\n    return encoding ? promise2.then((buff) => buff.toString(encoding)) : promise2;\n  }\n  if (\"body\" in event.req) {\n    return Promise.resolve(event.req.body);\n  }\n  const promise = event.req[RawBodySymbol] = new Promise((resolve, reject) => {\n    const bodyData = [];\n    event.req.on(\"error\", (err) => {\n      reject(err);\n    }).on(\"data\", (chunk) => {\n      bodyData.push(chunk);\n    }).on(\"end\", () => {\n      resolve(Buffer.concat(bodyData));\n    });\n  });\n  return encoding ? promise.then((buff) => buff.toString(encoding)) : promise;\n}\nconst useRawBody = readRawBody;\nasync function readBody(event) {\n  if (ParsedBodySymbol in event.req) {\n    return event.req[ParsedBodySymbol];\n  }\n  const body = await readRawBody(event);\n  if (event.req.headers[\"content-type\"] === \"application/x-www-form-urlencoded\") {\n    const parsedForm = Object.fromEntries(new URLSearchParams(body));\n    return parsedForm;\n  }\n  const json = destr(body);\n  event.req[ParsedBodySymbol] = json;\n  return json;\n}\nconst useBody = readBody;\n\nfunction handleCacheHeaders(event, opts) {\n  const cacheControls = [\"public\"].concat(opts.cacheControls || []);\n  let cacheMatched = false;\n  if (opts.maxAge !== void 0) {\n    cacheControls.push(`max-age=${+opts.maxAge}`, `s-maxage=${+opts.maxAge}`);\n  }\n  if (opts.modifiedTime) {\n    const modifiedTime = new Date(opts.modifiedTime);\n    const ifModifiedSince = event.req.headers[\"if-modified-since\"];\n    event.res.setHeader(\"Last-Modified\", modifiedTime.toUTCString());\n    if (ifModifiedSince) {\n      if (new Date(ifModifiedSince) >= opts.modifiedTime) {\n        cacheMatched = true;\n      }\n    }\n  }\n  if (opts.etag) {\n    event.res.setHeader(\"Etag\", opts.etag);\n    const ifNonMatch = event.req.headers[\"if-none-match\"];\n    if (ifNonMatch === opts.etag) {\n      cacheMatched = true;\n    }\n  }\n  event.res.setHeader(\"Cache-Control\", cacheControls.join(\", \"));\n  if (cacheMatched) {\n    event.res.statusCode = 304;\n    event.res.end(\"\");\n    return true;\n  }\n  return false;\n}\n\nconst MIMES = {\n  html: \"text/html\",\n  json: \"application/json\"\n};\n\nconst defer = typeof setImmediate !== \"undefined\" ? setImmediate : (fn) => fn();\nfunction send(event, data, type) {\n  if (type) {\n    defaultContentType(event, type);\n  }\n  return new Promise((resolve) => {\n    defer(() => {\n      event.res.end(data);\n      resolve(void 0);\n    });\n  });\n}\nfunction defaultContentType(event, type) {\n  if (type && !event.res.getHeader(\"Content-Type\")) {\n    event.res.setHeader(\"Content-Type\", type);\n  }\n}\nfunction sendRedirect(event, location, code = 302) {\n  event.res.statusCode = code;\n  event.res.setHeader(\"Location\", location);\n  const encodedLoc = location.replace(/\"/g, \"%22\");\n  const html = `<!DOCTYPE html><html><head><meta http-equiv=\"refresh\" content=\"0; url=${encodedLoc}\"></head></html>`;\n  return send(event, html, MIMES.html);\n}\nfunction getResponseHeaders(event) {\n  return event.res.getHeaders();\n}\nfunction getResponseHeader(event, name) {\n  return event.res.getHeader(name);\n}\nfunction setResponseHeaders(event, headers) {\n  Object.entries(headers).forEach(([name, value]) => event.res.setHeader(name, value));\n}\nconst setHeaders = setResponseHeaders;\nfunction setResponseHeader(event, name, value) {\n  event.res.setHeader(name, value);\n}\nconst setHeader = setResponseHeader;\nfunction appendResponseHeaders(event, headers) {\n  Object.entries(headers).forEach(([name, value]) => appendResponseHeader(event, name, value));\n}\nconst appendHeaders = appendResponseHeaders;\nfunction appendResponseHeader(event, name, value) {\n  let current = event.res.getHeader(name);\n  if (!current) {\n    event.res.setHeader(name, value);\n    return;\n  }\n  if (!Array.isArray(current)) {\n    current = [current.toString()];\n  }\n  event.res.setHeader(name, current.concat(value));\n}\nconst appendHeader = appendResponseHeader;\nfunction isStream(data) {\n  return data && typeof data === \"object\" && typeof data.pipe === \"function\" && typeof data.on === \"function\";\n}\nfunction sendStream(event, data) {\n  return new Promise((resolve, reject) => {\n    data.pipe(event.res);\n    data.on(\"end\", () => resolve(void 0));\n    data.on(\"error\", (error) => reject(createError(error)));\n  });\n}\n\nfunction parseCookies(event) {\n  return parse(event.req.headers.cookie || \"\");\n}\nconst useCookies = parseCookies;\nfunction getCookie(event, name) {\n  return parseCookies(event)[name];\n}\nconst useCookie = getCookie;\nfunction setCookie(event, name, value, serializeOptions) {\n  const cookieStr = serialize(name, value, {\n    path: \"/\",\n    ...serializeOptions\n  });\n  appendHeader(event, \"Set-Cookie\", cookieStr);\n}\nfunction deleteCookie(event, name, serializeOptions) {\n  setCookie(event, name, \"\", {\n    ...serializeOptions,\n    maxAge: 0\n  });\n}\n\nclass H3Headers {\n  constructor(init) {\n    if (!init) {\n      this._headers = {};\n    } else if (Array.isArray(init)) {\n      this._headers = Object.fromEntries(init.map(([key, value]) => [key.toLowerCase(), value]));\n    } else if (init && \"append\" in init) {\n      this._headers = Object.fromEntries([...init.entries()]);\n    } else {\n      this._headers = Object.fromEntries(Object.entries(init).map(([key, value]) => [key.toLowerCase(), value]));\n    }\n  }\n  append(name, value) {\n    const _name = name.toLowerCase();\n    this.set(_name, [this.get(_name), value].filter(Boolean).join(\", \"));\n  }\n  delete(name) {\n    delete this._headers[name.toLowerCase()];\n  }\n  get(name) {\n    return this._headers[name.toLowerCase()];\n  }\n  has(name) {\n    return name.toLowerCase() in this._headers;\n  }\n  set(name, value) {\n    this._headers[name.toLowerCase()] = String(value);\n  }\n  forEach(callbackfn) {\n    Object.entries(this._headers).forEach(([key, value]) => callbackfn(value, key, this));\n  }\n}\n\nclass H3Response {\n  constructor(body = null, init = {}) {\n    this.body = null;\n    this.type = \"default\";\n    this.bodyUsed = false;\n    this.headers = new H3Headers(init.headers);\n    this.status = init.status ?? 200;\n    this.statusText = init.statusText || \"\";\n    this.redirected = !!init.status && [301, 302, 307, 308].includes(init.status);\n    this._body = body;\n    this.url = \"\";\n    this.ok = this.status < 300 && this.status > 199;\n  }\n  clone() {\n    return new H3Response(this.body, {\n      headers: this.headers,\n      status: this.status,\n      statusText: this.statusText\n    });\n  }\n  arrayBuffer() {\n    return Promise.resolve(this._body);\n  }\n  blob() {\n    return Promise.resolve(this._body);\n  }\n  formData() {\n    return Promise.resolve(this._body);\n  }\n  json() {\n    return Promise.resolve(this._body);\n  }\n  text() {\n    return Promise.resolve(this._body);\n  }\n}\n\nclass H3Event {\n  constructor(req, res) {\n    this[\"__is_event__\"] = true;\n    this.context = {};\n    this.req = req;\n    this.res = res;\n    this.event = this;\n    req.event = this;\n    req.context = this.context;\n    req.req = req;\n    req.res = res;\n    res.event = this;\n    res.res = res;\n    res.req = res.req || {};\n    res.req.res = res;\n    res.req.req = req;\n  }\n  respondWith(r) {\n    Promise.resolve(r).then((_response) => {\n      if (this.res.writableEnded) {\n        return;\n      }\n      const response = _response instanceof H3Response ? _response : new H3Response(_response);\n      response.headers.forEach((value, key) => {\n        this.res.setHeader(key, value);\n      });\n      if (response.status) {\n        this.res.statusCode = response.status;\n      }\n      if (response.statusText) {\n        this.res.statusMessage = response.statusText;\n      }\n      if (response.redirected) {\n        this.res.setHeader(\"Location\", response.url);\n      }\n      if (!response._body) {\n        return this.res.end();\n      }\n      if (typeof response._body === \"string\" || \"buffer\" in response._body || \"byteLength\" in response._body) {\n        return this.res.end(response._body);\n      }\n      if (!response.headers.has(\"content-type\")) {\n        response.headers.set(\"content-type\", MIMES.json);\n      }\n      this.res.end(JSON.stringify(response._body));\n    });\n  }\n}\nfunction isEvent(input) {\n  return \"__is_event__\" in input;\n}\nfunction createEvent(req, res) {\n  return new H3Event(req, res);\n}\n\nconst defineHandler = (handler) => handler;\nconst defineHandle = defineHandler;\nconst defineMiddleware = (middleware) => middleware;\nfunction promisifyHandler(handler) {\n  return function(req, res) {\n    return callHandler(handler, req, res);\n  };\n}\nconst promisifyHandle = promisifyHandler;\nfunction callHandler(handler, req, res) {\n  const isMiddleware = handler.length > 2;\n  return new Promise((resolve, reject) => {\n    const next = (err) => {\n      if (isMiddleware) {\n        res.off(\"close\", next);\n        res.off(\"error\", next);\n      }\n      return err ? reject(createError(err)) : resolve(void 0);\n    };\n    try {\n      const returned = handler(req, res, next);\n      if (isMiddleware && returned === void 0) {\n        res.once(\"close\", next);\n        res.once(\"error\", next);\n      } else {\n        resolve(returned);\n      }\n    } catch (err) {\n      next(err);\n    }\n  });\n}\nfunction defineLazyHandler(handler, promisify) {\n  let _promise;\n  const resolve = () => {\n    if (!_promise) {\n      _promise = Promise.resolve(handler()).then((r) => promisify ? promisifyHandler(r.default || r) : r.default || r);\n    }\n    return _promise;\n  };\n  return function(req, res) {\n    return resolve().then((h) => h(req, res));\n  };\n}\nconst lazyHandle = defineLazyHandler;\nfunction useBase(base, handler) {\n  base = withoutTrailingSlash(base);\n  if (!base) {\n    return handler;\n  }\n  return function(req, res) {\n    req.originalUrl = req.originalUrl || req.url || \"/\";\n    req.url = withoutBase(req.url || \"/\", base);\n    return handler(req, res);\n  };\n}\n\nfunction defineEventHandler(handler) {\n  handler.__is_handler__ = true;\n  return handler;\n}\nconst eventHandler = defineEventHandler;\nfunction isEventHandler(input) {\n  return \"__is_handler__\" in input;\n}\nfunction toEventHandler(handler) {\n  if (isEventHandler(handler)) {\n    return handler;\n  }\n  if (typeof handler !== \"function\") {\n    throw new TypeError(\"Invalid handler. It should be a function:\", handler);\n  }\n  return eventHandler((event) => {\n    return callHandler(handler, event.req, event.res);\n  });\n}\nfunction dynamicEventHandler(initial) {\n  let current = initial;\n  const wrapper = eventHandler((event) => {\n    if (current) {\n      return current(event);\n    }\n  });\n  wrapper.set = (handler) => {\n    current = handler;\n  };\n  return wrapper;\n}\nfunction defineLazyEventHandler(factory) {\n  let _promise;\n  let _resolved;\n  const resolveHandler = () => {\n    if (_resolved) {\n      return Promise.resolve(_resolved);\n    }\n    if (!_promise) {\n      _promise = Promise.resolve(factory()).then((r) => {\n        const handler = r.default || r;\n        if (typeof handler !== \"function\") {\n          throw new TypeError(\"Invalid lazy handler result. It should be a function:\", handler);\n        }\n        _resolved = toEventHandler(r.default || r);\n        return _resolved;\n      });\n    }\n    return _promise;\n  };\n  return eventHandler((event) => {\n    if (_resolved) {\n      return _resolved(event);\n    }\n    return resolveHandler().then((handler) => handler(event));\n  });\n}\nconst lazyEventHandler = defineLazyEventHandler;\n\nfunction createApp(options = {}) {\n  const stack = [];\n  const handler = createAppEventHandler(stack, options);\n  const nodeHandler = async function(req, res) {\n    const event = createEvent(req, res);\n    try {\n      await handler(event);\n    } catch (_error) {\n      const error = createError(_error);\n      if (!isError(_error)) {\n        error.unhandled = true;\n      }\n      if (options.onError) {\n        await options.onError(error, event);\n      } else {\n        if (error.unhandled || error.fatal) {\n          console.error(\"[h3]\", error.fatal ? \"[fatal]\" : \"[unhandled]\", error);\n        }\n        await sendError(event, error, !!options.debug);\n      }\n    }\n  };\n  const app = nodeHandler;\n  app.nodeHandler = nodeHandler;\n  app.stack = stack;\n  app.handler = handler;\n  app.use = (arg1, arg2, arg3) => use(app, arg1, arg2, arg3);\n  return app;\n}\nfunction use(app, arg1, arg2, arg3) {\n  if (Array.isArray(arg1)) {\n    arg1.forEach((i) => use(app, i, arg2, arg3));\n  } else if (Array.isArray(arg2)) {\n    arg2.forEach((i) => use(app, arg1, i, arg3));\n  } else if (typeof arg1 === \"string\") {\n    app.stack.push(normalizeLayer({ ...arg3, route: arg1, handler: arg2 }));\n  } else if (typeof arg1 === \"function\") {\n    app.stack.push(normalizeLayer({ ...arg2, route: \"/\", handler: arg1 }));\n  } else {\n    app.stack.push(normalizeLayer({ ...arg1 }));\n  }\n  return app;\n}\nfunction createAppEventHandler(stack, options) {\n  const spacing = options.debug ? 2 : void 0;\n  return eventHandler(async (event) => {\n    event.req.originalUrl = event.req.originalUrl || event.req.url || \"/\";\n    const reqUrl = event.req.url || \"/\";\n    for (const layer of stack) {\n      if (layer.route.length > 1) {\n        if (!reqUrl.startsWith(layer.route)) {\n          continue;\n        }\n        event.req.url = reqUrl.slice(layer.route.length) || \"/\";\n      } else {\n        event.req.url = reqUrl;\n      }\n      if (layer.match && !layer.match(event.req.url, event)) {\n        continue;\n      }\n      const val = await layer.handler(event);\n      if (event.res.writableEnded) {\n        return;\n      }\n      const type = typeof val;\n      if (type === \"string\") {\n        return send(event, val, MIMES.html);\n      } else if (isStream(val)) {\n        return sendStream(event, val);\n      } else if (val === null) {\n        event.res.statusCode = 204;\n        return send(event);\n      } else if (type === \"object\" || type === \"boolean\" || type === \"number\") {\n        if (val.buffer) {\n          return send(event, val);\n        } else if (val instanceof Error) {\n          throw createError(val);\n        } else {\n          return send(event, JSON.stringify(val, null, spacing), MIMES.json);\n        }\n      }\n    }\n    if (!event.res.writableEnded) {\n      throw createError({ statusCode: 404, statusMessage: \"Not Found\" });\n    }\n  });\n}\nfunction normalizeLayer(input) {\n  let handler = input.handler || input.handle;\n  if (handler.handler) {\n    handler = handler.handler;\n  }\n  if (input.lazy) {\n    handler = lazyEventHandler(handler);\n  } else if (!isEventHandler(handler)) {\n    handler = toEventHandler(handler);\n  }\n  return {\n    route: withoutTrailingSlash(input.route),\n    match: input.match,\n    handler\n  };\n}\n\nconst RouterMethods = [\"connect\", \"delete\", \"get\", \"head\", \"options\", \"post\", \"put\", \"trace\", \"patch\"];\nfunction createRouter() {\n  const _router = createRouter$1({});\n  const routes = {};\n  const router = {};\n  const addRoute = (path, handler, method) => {\n    let route = routes[path];\n    if (!route) {\n      routes[path] = route = { handlers: {} };\n      _router.insert(path, route);\n    }\n    if (Array.isArray(method)) {\n      method.forEach((m) => addRoute(path, handler, m));\n    } else {\n      route.handlers[method] = toEventHandler(handler);\n    }\n    return router;\n  };\n  router.use = router.add = (path, handler, method) => addRoute(path, handler, method || \"all\");\n  for (const method of RouterMethods) {\n    router[method] = (path, handle) => router.add(path, handle, method);\n  }\n  router.handler = eventHandler((event) => {\n    let path = event.req.url || \"/\";\n    const queryUrlIndex = path.lastIndexOf(\"?\");\n    if (queryUrlIndex > -1) {\n      path = path.substring(0, queryUrlIndex);\n    }\n    const matched = _router.lookup(path);\n    if (!matched) {\n      throw createError({\n        statusCode: 404,\n        name: \"Not Found\",\n        statusMessage: `Cannot find any route matching ${event.req.url || \"/\"}.`\n      });\n    }\n    const method = (event.req.method || \"get\").toLowerCase();\n    const handler = matched.handlers[method] || matched.handlers.all;\n    if (!handler) {\n      throw createError({\n        statusCode: 405,\n        name: \"Method Not Allowed\",\n        statusMessage: `Method ${method} is not allowed on this route.`\n      });\n    }\n    const params = matched.params || {};\n    event.event.context.params = params;\n    event.req.context.params = params;\n    return handler(event);\n  });\n  return router;\n}\n\nexport { H3Error, H3Event, H3Headers, H3Response, MIMES, appendHeader, appendHeaders, appendResponseHeader, appendResponseHeaders, assertMethod, callHandler, createApp, createAppEventHandler, createError, createEvent, createRouter, defaultContentType, defineEventHandler, defineHandle, defineHandler, defineLazyEventHandler, defineLazyHandler, defineMiddleware, deleteCookie, dynamicEventHandler, eventHandler, getCookie, getHeader, getHeaders, getMethod, getQuery, getRequestHeader, getRequestHeaders, getResponseHeader, getResponseHeaders, getRouterParam, getRouterParams, handleCacheHeaders, isError, isEvent, isEventHandler, isMethod, isStream, lazyEventHandler, lazyHandle, parseCookies, promisifyHandle, promisifyHandler, readBody, readRawBody, send, sendError, sendRedirect, sendStream, setCookie, setHeader, setHeaders, setResponseHeader, setResponseHeaders, toEventHandler, use, useBase, useBody, useCookie, useCookies, useMethod, useQuery, useRawBody };\n","import { createError as _createError } from \"h3\";\nimport { toRef } from \"vue\";\nimport { useNuxtApp } from \"../nuxt.mjs\";\nexport const useError = () => toRef(useNuxtApp().payload, \"error\");\nexport const showError = (_err) => {\n  const err = createError(_err);\n  try {\n    const nuxtApp = useNuxtApp();\n    nuxtApp.callHook(\"app:error\", err);\n    const error = useError();\n    error.value = error.value || err;\n  } catch {\n    throw err;\n  }\n  return err;\n};\nexport const throwError = showError;\nexport const clearError = async (options = {}) => {\n  const nuxtApp = useNuxtApp();\n  const error = useError();\n  nuxtApp.callHook(\"app:error:cleared\", options);\n  if (options.redirect) {\n    await nuxtApp.$router.replace(options.redirect);\n  }\n  error.value = null;\n};\nexport const isNuxtError = (err) => !!(err && typeof err === \"object\" && \"__nuxt_error\" in err);\nexport const createError = (err) => {\n  const _err = _createError(err);\n  _err.__nuxt_error = true;\n  return _err;\n};\n","import { getCurrentInstance, inject } from \"vue\";\nimport { sendRedirect } from \"h3\";\nimport { hasProtocol, joinURL, parseURL } from \"ufo\";\nimport { useNuxtApp, useRuntimeConfig } from \"../nuxt.mjs\";\nimport { createError } from \"./error.mjs\";\nimport { useState } from \"./state.mjs\";\nexport const useRouter = () => {\n  return useNuxtApp()?.$router;\n};\nexport const useRoute = () => {\n  if (getCurrentInstance()) {\n    return inject(\"_route\", useNuxtApp()._route);\n  }\n  return useNuxtApp()._route;\n};\nexport const useActiveRoute = () => {\n  return useNuxtApp()._route;\n};\nexport const defineNuxtRouteMiddleware = (middleware) => middleware;\nexport const addRouteMiddleware = (name, middleware, options = {}) => {\n  const nuxtApp = useNuxtApp();\n  if (options.global || typeof name === \"function\") {\n    nuxtApp._middleware.global.push(typeof name === \"function\" ? name : middleware);\n  } else {\n    nuxtApp._middleware.named[name] = middleware;\n  }\n};\nconst isProcessingMiddleware = () => {\n  try {\n    if (useNuxtApp()._processingMiddleware) {\n      return true;\n    }\n  } catch {\n    return true;\n  }\n  return false;\n};\nexport const navigateTo = (to, options) => {\n  if (!to) {\n    to = \"/\";\n  }\n  const toPath = typeof to === \"string\" ? to : to.path || \"/\";\n  const isExternal = hasProtocol(toPath, true);\n  if (isExternal && !options?.external) {\n    throw new Error(\"Navigating to external URL is not allowed by default. Use `nagivateTo (url, { external: true })`.\");\n  }\n  if (isExternal && parseURL(toPath).protocol === \"script:\") {\n    throw new Error(\"Cannot navigate to an URL with script protocol.\");\n  }\n  if (process.client && !isExternal && isProcessingMiddleware()) {\n    return to;\n  }\n  const router = useRouter();\n  if (process.server) {\n    const nuxtApp = useNuxtApp();\n    if (nuxtApp.ssrContext && nuxtApp.ssrContext.event) {\n      const redirectLocation = isExternal ? toPath : joinURL(useRuntimeConfig().app.baseURL, router.resolve(to).fullPath || \"/\");\n      return nuxtApp.callHook(\"app:redirected\").then(() => sendRedirect(nuxtApp.ssrContext.event, redirectLocation, options?.redirectCode || 302));\n    }\n  }\n  if (isExternal) {\n    if (options?.replace) {\n      location.replace(toPath);\n    } else {\n      location.href = toPath;\n    }\n    return Promise.resolve();\n  }\n  return options?.replace ? router.replace(to) : router.push(to);\n};\nexport const abortNavigation = (err) => {\n  if (process.dev && !isProcessingMiddleware()) {\n    throw new Error(\"abortNavigation() is only usable inside a route middleware handler.\");\n  }\n  if (err) {\n    throw createError(err);\n  }\n  return false;\n};\nexport const setPageLayout = (layout) => {\n  if (process.server) {\n    useState(\"_layout\").value = layout;\n  }\n  const nuxtApp = useNuxtApp();\n  const inMiddleware = isProcessingMiddleware();\n  if (inMiddleware || process.server || nuxtApp.isHydrating) {\n    const unsubscribe = useRouter().beforeResolve((to) => {\n      to.meta.layout = layout;\n      unsubscribe();\n    });\n  }\n  if (!inMiddleware) {\n    useRoute().meta.layout = layout;\n  }\n};\n","import { defineComponent, h, ref, resolveComponent, computed, onMounted, onBeforeUnmount } from \"vue\";\nimport { hasProtocol } from \"ufo\";\nimport { navigateTo, useRouter } from \"../composables/router.mjs\";\nimport { useNuxtApp } from \"../nuxt.mjs\";\nconst firstNonUndefined = (...args) => args.find((arg) => arg !== void 0);\nconst DEFAULT_EXTERNAL_REL_ATTRIBUTE = \"noopener noreferrer\";\nconst requestIdleCallback = process.server ? void 0 : globalThis.requestIdleCallback || ((cb) => {\n  const start = Date.now();\n  const idleDeadline = {\n    didTimeout: false,\n    timeRemaining: () => Math.max(0, 50 - (Date.now() - start))\n  };\n  return setTimeout(() => {\n    cb(idleDeadline);\n  }, 1);\n});\nconst cancelIdleCallback = process.server ? null : globalThis.cancelIdleCallback || ((id) => {\n  clearTimeout(id);\n});\nexport function defineNuxtLink(options) {\n  const componentName = options.componentName || \"NuxtLink\";\n  const checkPropConflicts = (props, main, sub) => {\n    if (process.dev && props[main] !== void 0 && props[sub] !== void 0) {\n      console.warn(`[${componentName}] \\`${main}\\` and \\`${sub}\\` cannot be used together. \\`${sub}\\` will be ignored.`);\n    }\n  };\n  return defineComponent({\n    name: componentName,\n    props: {\n      to: {\n        type: [String, Object],\n        default: void 0,\n        required: false\n      },\n      href: {\n        type: [String, Object],\n        default: void 0,\n        required: false\n      },\n      target: {\n        type: String,\n        default: void 0,\n        required: false\n      },\n      rel: {\n        type: String,\n        default: void 0,\n        required: false\n      },\n      noRel: {\n        type: Boolean,\n        default: void 0,\n        required: false\n      },\n      prefetch: {\n        type: Boolean,\n        default: void 0,\n        required: false\n      },\n      noPrefetch: {\n        type: Boolean,\n        default: void 0,\n        required: false\n      },\n      activeClass: {\n        type: String,\n        default: void 0,\n        required: false\n      },\n      exactActiveClass: {\n        type: String,\n        default: void 0,\n        required: false\n      },\n      prefetchedClass: {\n        type: String,\n        default: void 0,\n        required: false\n      },\n      replace: {\n        type: Boolean,\n        default: void 0,\n        required: false\n      },\n      ariaCurrentValue: {\n        type: String,\n        default: void 0,\n        required: false\n      },\n      external: {\n        type: Boolean,\n        default: void 0,\n        required: false\n      },\n      custom: {\n        type: Boolean,\n        default: void 0,\n        required: false\n      }\n    },\n    setup(props, { slots }) {\n      const router = useRouter();\n      const to = computed(() => {\n        checkPropConflicts(props, \"to\", \"href\");\n        return props.to || props.href || \"\";\n      });\n      const isExternal = computed(() => {\n        if (props.external) {\n          return true;\n        }\n        if (props.target && props.target !== \"_self\") {\n          return true;\n        }\n        if (typeof to.value === \"object\") {\n          return false;\n        }\n        return to.value === \"\" || hasProtocol(to.value, true);\n      });\n      const prefetched = ref(false);\n      const el = process.server ? void 0 : ref(null);\n      if (process.client) {\n        checkPropConflicts(props, \"prefetch\", \"noPrefetch\");\n        const shouldPrefetch = props.prefetch !== false && props.noPrefetch !== true && typeof to.value === \"string\" && !isSlowConnection();\n        if (shouldPrefetch) {\n          const nuxtApp = useNuxtApp();\n          const observer = useObserver();\n          let idleId;\n          let unobserve = null;\n          onMounted(() => {\n            idleId = requestIdleCallback(() => {\n              if (el?.value?.tagName) {\n                unobserve = observer.observe(el.value, async () => {\n                  unobserve?.();\n                  unobserve = null;\n                  await Promise.all([\n                    nuxtApp.hooks.callHook(\"link:prefetch\", to.value).catch(() => {\n                    }),\n                    preloadRouteComponents(to.value, router).catch(() => {\n                    })\n                  ]);\n                  prefetched.value = true;\n                });\n              }\n            });\n          });\n          onBeforeUnmount(() => {\n            if (idleId) {\n              cancelIdleCallback(idleId);\n            }\n            unobserve?.();\n            unobserve = null;\n          });\n        }\n      }\n      return () => {\n        if (!isExternal.value) {\n          return h(\n            resolveComponent(\"RouterLink\"),\n            {\n              ref: process.server ? void 0 : (ref2) => {\n                el.value = ref2?.$el;\n              },\n              to: to.value,\n              ...prefetched.value && !props.custom ? { class: props.prefetchedClass || options.prefetchedClass } : {},\n              activeClass: props.activeClass || options.activeClass,\n              exactActiveClass: props.exactActiveClass || options.exactActiveClass,\n              replace: props.replace,\n              ariaCurrentValue: props.ariaCurrentValue,\n              custom: props.custom\n            },\n            slots.default\n          );\n        }\n        const href = typeof to.value === \"object\" ? router.resolve(to.value)?.href ?? null : to.value || null;\n        const target = props.target || null;\n        checkPropConflicts(props, \"noRel\", \"rel\");\n        const rel = props.noRel ? null : firstNonUndefined(props.rel, options.externalRelAttribute, href ? DEFAULT_EXTERNAL_REL_ATTRIBUTE : \"\") || null;\n        const navigate = () => navigateTo(href, { replace: props.replace });\n        if (props.custom) {\n          if (!slots.default) {\n            return null;\n          }\n          return slots.default({\n            href,\n            navigate,\n            route: router.resolve(href),\n            rel,\n            target,\n            isActive: false,\n            isExactActive: false\n          });\n        }\n        return h(\"a\", { href, rel, target }, slots.default?.());\n      };\n    }\n  });\n}\nexport default defineNuxtLink({ componentName: \"NuxtLink\" });\nfunction useObserver() {\n  if (process.server) {\n    return;\n  }\n  const nuxtApp = useNuxtApp();\n  if (nuxtApp._observer) {\n    return nuxtApp._observer;\n  }\n  let observer = null;\n  const callbacks = /* @__PURE__ */ new Map();\n  const observe = (element, callback) => {\n    if (!observer) {\n      observer = new IntersectionObserver((entries) => {\n        for (const entry of entries) {\n          const callback2 = callbacks.get(entry.target);\n          const isVisible = entry.isIntersecting || entry.intersectionRatio > 0;\n          if (isVisible && callback2) {\n            callback2();\n          }\n        }\n      });\n    }\n    callbacks.set(element, callback);\n    observer.observe(element);\n    return () => {\n      callbacks.delete(element);\n      observer.unobserve(element);\n      if (callbacks.size === 0) {\n        observer.disconnect();\n        observer = null;\n      }\n    };\n  };\n  const _observer = nuxtApp._observer = {\n    observe\n  };\n  return _observer;\n}\nfunction isSlowConnection() {\n  if (process.server) {\n    return;\n  }\n  const cn = navigator.connection;\n  if (cn && (cn.saveData || /2g/.test(cn.effectiveType))) {\n    return true;\n  }\n  return false;\n}\nasync function preloadRouteComponents(to, router = useRouter()) {\n  if (process.server) {\n    return;\n  }\n  if (!router._nuxtLinkPreloaded) {\n    router._nuxtLinkPreloaded = /* @__PURE__ */ new Set();\n  }\n  if (router._nuxtLinkPreloaded.has(to)) {\n    return;\n  }\n  router._nuxtLinkPreloaded.add(to);\n  const components = router.resolve(to).matched.map((component) => component.components?.default).filter((component) => typeof component === \"function\");\n  const promises = [];\n  for (const component of components) {\n    const promise = Promise.resolve(component()).catch(() => {\n    });\n    promises.push(promise);\n  }\n  await Promise.all(promises);\n}\n","function isObject(val) {\n  return val !== null && typeof val === \"object\";\n}\nfunction _defu(baseObj, defaults, namespace = \".\", merger) {\n  if (!isObject(defaults)) {\n    return _defu(baseObj, {}, namespace, merger);\n  }\n  const obj = Object.assign({}, defaults);\n  for (const key in baseObj) {\n    if (key === \"__proto__\" || key === \"constructor\") {\n      continue;\n    }\n    const val = baseObj[key];\n    if (val === null || val === void 0) {\n      continue;\n    }\n    if (merger && merger(obj, key, val, namespace)) {\n      continue;\n    }\n    if (Array.isArray(val) && Array.isArray(obj[key])) {\n      obj[key] = val.concat(obj[key]);\n    } else if (isObject(val) && isObject(obj[key])) {\n      obj[key] = _defu(val, obj[key], (namespace ? `${namespace}.` : \"\") + key.toString(), merger);\n    } else {\n      obj[key] = val;\n    }\n  }\n  return obj;\n}\nfunction createDefu(merger) {\n  return (...args) => args.reduce((p, c) => _defu(p, c, \"\", merger), {});\n}\nconst defu = createDefu();\nconst defuFn = createDefu((obj, key, currentValue, _namespace) => {\n  if (typeof obj[key] !== \"undefined\" && typeof currentValue === \"function\") {\n    obj[key] = currentValue(obj[key]);\n    return true;\n  }\n});\nconst defuArrayFn = createDefu((obj, key, currentValue, _namespace) => {\n  if (Array.isArray(obj[key]) && typeof currentValue === \"function\") {\n    obj[key] = currentValue(obj[key]);\n    return true;\n  }\n});\n\nexport { createDefu, defu as default, defu, defuArrayFn, defuFn };\n","\nimport { defuFn } from 'defu'\n\nconst inlineConfig = {}\n\n\n\nexport default defuFn(inlineConfig)\n","/**\r\n * Make a map and return a function for checking if a key\r\n * is in that map.\r\n * IMPORTANT: all calls of this function must be prefixed with\r\n * \\/\\*#\\_\\_PURE\\_\\_\\*\\/\r\n * So that rollup can tree-shake them if necessary.\r\n */\r\nfunction makeMap(str, expectsLowerCase) {\r\n    const map = Object.create(null);\r\n    const list = str.split(',');\r\n    for (let i = 0; i < list.length; i++) {\r\n        map[list[i]] = true;\r\n    }\r\n    return expectsLowerCase ? val => !!map[val.toLowerCase()] : val => !!map[val];\r\n}\n\n/**\r\n * dev only flag -> name mapping\r\n */\r\nconst PatchFlagNames = {\r\n    [1 /* PatchFlags.TEXT */]: `TEXT`,\r\n    [2 /* PatchFlags.CLASS */]: `CLASS`,\r\n    [4 /* PatchFlags.STYLE */]: `STYLE`,\r\n    [8 /* PatchFlags.PROPS */]: `PROPS`,\r\n    [16 /* PatchFlags.FULL_PROPS */]: `FULL_PROPS`,\r\n    [32 /* PatchFlags.HYDRATE_EVENTS */]: `HYDRATE_EVENTS`,\r\n    [64 /* PatchFlags.STABLE_FRAGMENT */]: `STABLE_FRAGMENT`,\r\n    [128 /* PatchFlags.KEYED_FRAGMENT */]: `KEYED_FRAGMENT`,\r\n    [256 /* PatchFlags.UNKEYED_FRAGMENT */]: `UNKEYED_FRAGMENT`,\r\n    [512 /* PatchFlags.NEED_PATCH */]: `NEED_PATCH`,\r\n    [1024 /* PatchFlags.DYNAMIC_SLOTS */]: `DYNAMIC_SLOTS`,\r\n    [2048 /* PatchFlags.DEV_ROOT_FRAGMENT */]: `DEV_ROOT_FRAGMENT`,\r\n    [-1 /* PatchFlags.HOISTED */]: `HOISTED`,\r\n    [-2 /* PatchFlags.BAIL */]: `BAIL`\r\n};\n\n/**\r\n * Dev only\r\n */\r\nconst slotFlagsText = {\r\n    [1 /* SlotFlags.STABLE */]: 'STABLE',\r\n    [2 /* SlotFlags.DYNAMIC */]: 'DYNAMIC',\r\n    [3 /* SlotFlags.FORWARDED */]: 'FORWARDED'\r\n};\n\nconst GLOBALS_WHITE_LISTED = 'Infinity,undefined,NaN,isFinite,isNaN,parseFloat,parseInt,decodeURI,' +\r\n    'decodeURIComponent,encodeURI,encodeURIComponent,Math,Number,Date,Array,' +\r\n    'Object,Boolean,String,RegExp,Map,Set,JSON,Intl,BigInt';\r\nconst isGloballyWhitelisted = /*#__PURE__*/ makeMap(GLOBALS_WHITE_LISTED);\n\nconst range = 2;\r\nfunction generateCodeFrame(source, start = 0, end = source.length) {\r\n    // Split the content into individual lines but capture the newline sequence\r\n    // that separated each line. This is important because the actual sequence is\r\n    // needed to properly take into account the full line length for offset\r\n    // comparison\r\n    let lines = source.split(/(\\r?\\n)/);\r\n    // Separate the lines and newline sequences into separate arrays for easier referencing\r\n    const newlineSequences = lines.filter((_, idx) => idx % 2 === 1);\r\n    lines = lines.filter((_, idx) => idx % 2 === 0);\r\n    let count = 0;\r\n    const res = [];\r\n    for (let i = 0; i < lines.length; i++) {\r\n        count +=\r\n            lines[i].length +\r\n                ((newlineSequences[i] && newlineSequences[i].length) || 0);\r\n        if (count >= start) {\r\n            for (let j = i - range; j <= i + range || end > count; j++) {\r\n                if (j < 0 || j >= lines.length)\r\n                    continue;\r\n                const line = j + 1;\r\n                res.push(`${line}${' '.repeat(Math.max(3 - String(line).length, 0))}|  ${lines[j]}`);\r\n                const lineLength = lines[j].length;\r\n                const newLineSeqLength = (newlineSequences[j] && newlineSequences[j].length) || 0;\r\n                if (j === i) {\r\n                    // push underline\r\n                    const pad = start - (count - (lineLength + newLineSeqLength));\r\n                    const length = Math.max(1, end > count ? lineLength - pad : end - start);\r\n                    res.push(`   |  ` + ' '.repeat(pad) + '^'.repeat(length));\r\n                }\r\n                else if (j > i) {\r\n                    if (end > count) {\r\n                        const length = Math.max(Math.min(end - count, lineLength), 1);\r\n                        res.push(`   |  ` + '^'.repeat(length));\r\n                    }\r\n                    count += lineLength + newLineSeqLength;\r\n                }\r\n            }\r\n            break;\r\n        }\r\n    }\r\n    return res.join('\\n');\r\n}\n\n/**\r\n * On the client we only need to offer special cases for boolean attributes that\r\n * have different names from their corresponding dom properties:\r\n * - itemscope -> N/A\r\n * - allowfullscreen -> allowFullscreen\r\n * - formnovalidate -> formNoValidate\r\n * - ismap -> isMap\r\n * - nomodule -> noModule\r\n * - novalidate -> noValidate\r\n * - readonly -> readOnly\r\n */\r\nconst specialBooleanAttrs = `itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly`;\r\nconst isSpecialBooleanAttr = /*#__PURE__*/ makeMap(specialBooleanAttrs);\r\n/**\r\n * The full list is needed during SSR to produce the correct initial markup.\r\n */\r\nconst isBooleanAttr = /*#__PURE__*/ makeMap(specialBooleanAttrs +\r\n    `,async,autofocus,autoplay,controls,default,defer,disabled,hidden,` +\r\n    `loop,open,required,reversed,scoped,seamless,` +\r\n    `checked,muted,multiple,selected`);\r\n/**\r\n * Boolean attributes should be included if the value is truthy or ''.\r\n * e.g. `<select multiple>` compiles to `{ multiple: '' }`\r\n */\r\nfunction includeBooleanAttr(value) {\r\n    return !!value || value === '';\r\n}\r\nconst unsafeAttrCharRE = /[>/=\"'\\u0009\\u000a\\u000c\\u0020]/;\r\nconst attrValidationCache = {};\r\nfunction isSSRSafeAttrName(name) {\r\n    if (attrValidationCache.hasOwnProperty(name)) {\r\n        return attrValidationCache[name];\r\n    }\r\n    const isUnsafe = unsafeAttrCharRE.test(name);\r\n    if (isUnsafe) {\r\n        console.error(`unsafe attribute name: ${name}`);\r\n    }\r\n    return (attrValidationCache[name] = !isUnsafe);\r\n}\r\nconst propsToAttrMap = {\r\n    acceptCharset: 'accept-charset',\r\n    className: 'class',\r\n    htmlFor: 'for',\r\n    httpEquiv: 'http-equiv'\r\n};\r\n/**\r\n * CSS properties that accept plain numbers\r\n */\r\nconst isNoUnitNumericStyleProp = /*#__PURE__*/ makeMap(`animation-iteration-count,border-image-outset,border-image-slice,` +\r\n    `border-image-width,box-flex,box-flex-group,box-ordinal-group,column-count,` +\r\n    `columns,flex,flex-grow,flex-positive,flex-shrink,flex-negative,flex-order,` +\r\n    `grid-row,grid-row-end,grid-row-span,grid-row-start,grid-column,` +\r\n    `grid-column-end,grid-column-span,grid-column-start,font-weight,line-clamp,` +\r\n    `line-height,opacity,order,orphans,tab-size,widows,z-index,zoom,` +\r\n    // SVG\r\n    `fill-opacity,flood-opacity,stop-opacity,stroke-dasharray,stroke-dashoffset,` +\r\n    `stroke-miterlimit,stroke-opacity,stroke-width`);\r\n/**\r\n * Known attributes, this is used for stringification of runtime static nodes\r\n * so that we don't stringify bindings that cannot be set from HTML.\r\n * Don't also forget to allow `data-*` and `aria-*`!\r\n * Generated from https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes\r\n */\r\nconst isKnownHtmlAttr = /*#__PURE__*/ makeMap(`accept,accept-charset,accesskey,action,align,allow,alt,async,` +\r\n    `autocapitalize,autocomplete,autofocus,autoplay,background,bgcolor,` +\r\n    `border,buffered,capture,challenge,charset,checked,cite,class,code,` +\r\n    `codebase,color,cols,colspan,content,contenteditable,contextmenu,controls,` +\r\n    `coords,crossorigin,csp,data,datetime,decoding,default,defer,dir,dirname,` +\r\n    `disabled,download,draggable,dropzone,enctype,enterkeyhint,for,form,` +\r\n    `formaction,formenctype,formmethod,formnovalidate,formtarget,headers,` +\r\n    `height,hidden,high,href,hreflang,http-equiv,icon,id,importance,integrity,` +\r\n    `ismap,itemprop,keytype,kind,label,lang,language,loading,list,loop,low,` +\r\n    `manifest,max,maxlength,minlength,media,min,multiple,muted,name,novalidate,` +\r\n    `open,optimum,pattern,ping,placeholder,poster,preload,radiogroup,readonly,` +\r\n    `referrerpolicy,rel,required,reversed,rows,rowspan,sandbox,scope,scoped,` +\r\n    `selected,shape,size,sizes,slot,span,spellcheck,src,srcdoc,srclang,srcset,` +\r\n    `start,step,style,summary,tabindex,target,title,translate,type,usemap,` +\r\n    `value,width,wrap`);\r\n/**\r\n * Generated from https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute\r\n */\r\nconst isKnownSvgAttr = /*#__PURE__*/ makeMap(`xmlns,accent-height,accumulate,additive,alignment-baseline,alphabetic,amplitude,` +\r\n    `arabic-form,ascent,attributeName,attributeType,azimuth,baseFrequency,` +\r\n    `baseline-shift,baseProfile,bbox,begin,bias,by,calcMode,cap-height,class,` +\r\n    `clip,clipPathUnits,clip-path,clip-rule,color,color-interpolation,` +\r\n    `color-interpolation-filters,color-profile,color-rendering,` +\r\n    `contentScriptType,contentStyleType,crossorigin,cursor,cx,cy,d,decelerate,` +\r\n    `descent,diffuseConstant,direction,display,divisor,dominant-baseline,dur,dx,` +\r\n    `dy,edgeMode,elevation,enable-background,end,exponent,fill,fill-opacity,` +\r\n    `fill-rule,filter,filterRes,filterUnits,flood-color,flood-opacity,` +\r\n    `font-family,font-size,font-size-adjust,font-stretch,font-style,` +\r\n    `font-variant,font-weight,format,from,fr,fx,fy,g1,g2,glyph-name,` +\r\n    `glyph-orientation-horizontal,glyph-orientation-vertical,glyphRef,` +\r\n    `gradientTransform,gradientUnits,hanging,height,href,hreflang,horiz-adv-x,` +\r\n    `horiz-origin-x,id,ideographic,image-rendering,in,in2,intercept,k,k1,k2,k3,` +\r\n    `k4,kernelMatrix,kernelUnitLength,kerning,keyPoints,keySplines,keyTimes,` +\r\n    `lang,lengthAdjust,letter-spacing,lighting-color,limitingConeAngle,local,` +\r\n    `marker-end,marker-mid,marker-start,markerHeight,markerUnits,markerWidth,` +\r\n    `mask,maskContentUnits,maskUnits,mathematical,max,media,method,min,mode,` +\r\n    `name,numOctaves,offset,opacity,operator,order,orient,orientation,origin,` +\r\n    `overflow,overline-position,overline-thickness,panose-1,paint-order,path,` +\r\n    `pathLength,patternContentUnits,patternTransform,patternUnits,ping,` +\r\n    `pointer-events,points,pointsAtX,pointsAtY,pointsAtZ,preserveAlpha,` +\r\n    `preserveAspectRatio,primitiveUnits,r,radius,referrerPolicy,refX,refY,rel,` +\r\n    `rendering-intent,repeatCount,repeatDur,requiredExtensions,requiredFeatures,` +\r\n    `restart,result,rotate,rx,ry,scale,seed,shape-rendering,slope,spacing,` +\r\n    `specularConstant,specularExponent,speed,spreadMethod,startOffset,` +\r\n    `stdDeviation,stemh,stemv,stitchTiles,stop-color,stop-opacity,` +\r\n    `strikethrough-position,strikethrough-thickness,string,stroke,` +\r\n    `stroke-dasharray,stroke-dashoffset,stroke-linecap,stroke-linejoin,` +\r\n    `stroke-miterlimit,stroke-opacity,stroke-width,style,surfaceScale,` +\r\n    `systemLanguage,tabindex,tableValues,target,targetX,targetY,text-anchor,` +\r\n    `text-decoration,text-rendering,textLength,to,transform,transform-origin,` +\r\n    `type,u1,u2,underline-position,underline-thickness,unicode,unicode-bidi,` +\r\n    `unicode-range,units-per-em,v-alphabetic,v-hanging,v-ideographic,` +\r\n    `v-mathematical,values,vector-effect,version,vert-adv-y,vert-origin-x,` +\r\n    `vert-origin-y,viewBox,viewTarget,visibility,width,widths,word-spacing,` +\r\n    `writing-mode,x,x-height,x1,x2,xChannelSelector,xlink:actuate,xlink:arcrole,` +\r\n    `xlink:href,xlink:role,xlink:show,xlink:title,xlink:type,xml:base,xml:lang,` +\r\n    `xml:space,y,y1,y2,yChannelSelector,z,zoomAndPan`);\n\nfunction normalizeStyle(value) {\r\n    if (isArray(value)) {\r\n        const res = {};\r\n        for (let i = 0; i < value.length; i++) {\r\n            const item = value[i];\r\n            const normalized = isString(item)\r\n                ? parseStringStyle(item)\r\n                : normalizeStyle(item);\r\n            if (normalized) {\r\n                for (const key in normalized) {\r\n                    res[key] = normalized[key];\r\n                }\r\n            }\r\n        }\r\n        return res;\r\n    }\r\n    else if (isString(value)) {\r\n        return value;\r\n    }\r\n    else if (isObject(value)) {\r\n        return value;\r\n    }\r\n}\r\nconst listDelimiterRE = /;(?![^(]*\\))/g;\r\nconst propertyDelimiterRE = /:(.+)/;\r\nfunction parseStringStyle(cssText) {\r\n    const ret = {};\r\n    cssText.split(listDelimiterRE).forEach(item => {\r\n        if (item) {\r\n            const tmp = item.split(propertyDelimiterRE);\r\n            tmp.length > 1 && (ret[tmp[0].trim()] = tmp[1].trim());\r\n        }\r\n    });\r\n    return ret;\r\n}\r\nfunction stringifyStyle(styles) {\r\n    let ret = '';\r\n    if (!styles || isString(styles)) {\r\n        return ret;\r\n    }\r\n    for (const key in styles) {\r\n        const value = styles[key];\r\n        const normalizedKey = key.startsWith(`--`) ? key : hyphenate(key);\r\n        if (isString(value) ||\r\n            (typeof value === 'number' && isNoUnitNumericStyleProp(normalizedKey))) {\r\n            // only render valid values\r\n            ret += `${normalizedKey}:${value};`;\r\n        }\r\n    }\r\n    return ret;\r\n}\r\nfunction normalizeClass(value) {\r\n    let res = '';\r\n    if (isString(value)) {\r\n        res = value;\r\n    }\r\n    else if (isArray(value)) {\r\n        for (let i = 0; i < value.length; i++) {\r\n            const normalized = normalizeClass(value[i]);\r\n            if (normalized) {\r\n                res += normalized + ' ';\r\n            }\r\n        }\r\n    }\r\n    else if (isObject(value)) {\r\n        for (const name in value) {\r\n            if (value[name]) {\r\n                res += name + ' ';\r\n            }\r\n        }\r\n    }\r\n    return res.trim();\r\n}\r\nfunction normalizeProps(props) {\r\n    if (!props)\r\n        return null;\r\n    let { class: klass, style } = props;\r\n    if (klass && !isString(klass)) {\r\n        props.class = normalizeClass(klass);\r\n    }\r\n    if (style) {\r\n        props.style = normalizeStyle(style);\r\n    }\r\n    return props;\r\n}\n\n// These tag configs are shared between compiler-dom and runtime-dom, so they\r\n// https://developer.mozilla.org/en-US/docs/Web/HTML/Element\r\nconst HTML_TAGS = 'html,body,base,head,link,meta,style,title,address,article,aside,footer,' +\r\n    'header,h1,h2,h3,h4,h5,h6,nav,section,div,dd,dl,dt,figcaption,' +\r\n    'figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,' +\r\n    'data,dfn,em,i,kbd,mark,q,rp,rt,ruby,s,samp,small,span,strong,sub,sup,' +\r\n    'time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,' +\r\n    'canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,' +\r\n    'th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,' +\r\n    'option,output,progress,select,textarea,details,dialog,menu,' +\r\n    'summary,template,blockquote,iframe,tfoot';\r\n// https://developer.mozilla.org/en-US/docs/Web/SVG/Element\r\nconst SVG_TAGS = 'svg,animate,animateMotion,animateTransform,circle,clipPath,color-profile,' +\r\n    'defs,desc,discard,ellipse,feBlend,feColorMatrix,feComponentTransfer,' +\r\n    'feComposite,feConvolveMatrix,feDiffuseLighting,feDisplacementMap,' +\r\n    'feDistanceLight,feDropShadow,feFlood,feFuncA,feFuncB,feFuncG,feFuncR,' +\r\n    'feGaussianBlur,feImage,feMerge,feMergeNode,feMorphology,feOffset,' +\r\n    'fePointLight,feSpecularLighting,feSpotLight,feTile,feTurbulence,filter,' +\r\n    'foreignObject,g,hatch,hatchpath,image,line,linearGradient,marker,mask,' +\r\n    'mesh,meshgradient,meshpatch,meshrow,metadata,mpath,path,pattern,' +\r\n    'polygon,polyline,radialGradient,rect,set,solidcolor,stop,switch,symbol,' +\r\n    'text,textPath,title,tspan,unknown,use,view';\r\nconst VOID_TAGS = 'area,base,br,col,embed,hr,img,input,link,meta,param,source,track,wbr';\r\n/**\r\n * Compiler only.\r\n * Do NOT use in runtime code paths unless behind `(process.env.NODE_ENV !== 'production')` flag.\r\n */\r\nconst isHTMLTag = /*#__PURE__*/ makeMap(HTML_TAGS);\r\n/**\r\n * Compiler only.\r\n * Do NOT use in runtime code paths unless behind `(process.env.NODE_ENV !== 'production')` flag.\r\n */\r\nconst isSVGTag = /*#__PURE__*/ makeMap(SVG_TAGS);\r\n/**\r\n * Compiler only.\r\n * Do NOT use in runtime code paths unless behind `(process.env.NODE_ENV !== 'production')` flag.\r\n */\r\nconst isVoidTag = /*#__PURE__*/ makeMap(VOID_TAGS);\n\nconst escapeRE = /[\"'&<>]/;\r\nfunction escapeHtml(string) {\r\n    const str = '' + string;\r\n    const match = escapeRE.exec(str);\r\n    if (!match) {\r\n        return str;\r\n    }\r\n    let html = '';\r\n    let escaped;\r\n    let index;\r\n    let lastIndex = 0;\r\n    for (index = match.index; index < str.length; index++) {\r\n        switch (str.charCodeAt(index)) {\r\n            case 34: // \"\r\n                escaped = '&quot;';\r\n                break;\r\n            case 38: // &\r\n                escaped = '&amp;';\r\n                break;\r\n            case 39: // '\r\n                escaped = '&#39;';\r\n                break;\r\n            case 60: // <\r\n                escaped = '&lt;';\r\n                break;\r\n            case 62: // >\r\n                escaped = '&gt;';\r\n                break;\r\n            default:\r\n                continue;\r\n        }\r\n        if (lastIndex !== index) {\r\n            html += str.slice(lastIndex, index);\r\n        }\r\n        lastIndex = index + 1;\r\n        html += escaped;\r\n    }\r\n    return lastIndex !== index ? html + str.slice(lastIndex, index) : html;\r\n}\r\n// https://www.w3.org/TR/html52/syntax.html#comments\r\nconst commentStripRE = /^-?>|<!--|-->|--!>|<!-$/g;\r\nfunction escapeHtmlComment(src) {\r\n    return src.replace(commentStripRE, '');\r\n}\n\nfunction looseCompareArrays(a, b) {\r\n    if (a.length !== b.length)\r\n        return false;\r\n    let equal = true;\r\n    for (let i = 0; equal && i < a.length; i++) {\r\n        equal = looseEqual(a[i], b[i]);\r\n    }\r\n    return equal;\r\n}\r\nfunction looseEqual(a, b) {\r\n    if (a === b)\r\n        return true;\r\n    let aValidType = isDate(a);\r\n    let bValidType = isDate(b);\r\n    if (aValidType || bValidType) {\r\n        return aValidType && bValidType ? a.getTime() === b.getTime() : false;\r\n    }\r\n    aValidType = isSymbol(a);\r\n    bValidType = isSymbol(b);\r\n    if (aValidType || bValidType) {\r\n        return a === b;\r\n    }\r\n    aValidType = isArray(a);\r\n    bValidType = isArray(b);\r\n    if (aValidType || bValidType) {\r\n        return aValidType && bValidType ? looseCompareArrays(a, b) : false;\r\n    }\r\n    aValidType = isObject(a);\r\n    bValidType = isObject(b);\r\n    if (aValidType || bValidType) {\r\n        /* istanbul ignore if: this if will probably never be called */\r\n        if (!aValidType || !bValidType) {\r\n            return false;\r\n        }\r\n        const aKeysCount = Object.keys(a).length;\r\n        const bKeysCount = Object.keys(b).length;\r\n        if (aKeysCount !== bKeysCount) {\r\n            return false;\r\n        }\r\n        for (const key in a) {\r\n            const aHasKey = a.hasOwnProperty(key);\r\n            const bHasKey = b.hasOwnProperty(key);\r\n            if ((aHasKey && !bHasKey) ||\r\n                (!aHasKey && bHasKey) ||\r\n                !looseEqual(a[key], b[key])) {\r\n                return false;\r\n            }\r\n        }\r\n    }\r\n    return String(a) === String(b);\r\n}\r\nfunction looseIndexOf(arr, val) {\r\n    return arr.findIndex(item => looseEqual(item, val));\r\n}\n\n/**\r\n * For converting {{ interpolation }} values to displayed strings.\r\n * @private\r\n */\r\nconst toDisplayString = (val) => {\r\n    return isString(val)\r\n        ? val\r\n        : val == null\r\n            ? ''\r\n            : isArray(val) ||\r\n                (isObject(val) &&\r\n                    (val.toString === objectToString || !isFunction(val.toString)))\r\n                ? JSON.stringify(val, replacer, 2)\r\n                : String(val);\r\n};\r\nconst replacer = (_key, val) => {\r\n    // can't use isRef here since @vue/shared has no deps\r\n    if (val && val.__v_isRef) {\r\n        return replacer(_key, val.value);\r\n    }\r\n    else if (isMap(val)) {\r\n        return {\r\n            [`Map(${val.size})`]: [...val.entries()].reduce((entries, [key, val]) => {\r\n                entries[`${key} =>`] = val;\r\n                return entries;\r\n            }, {})\r\n        };\r\n    }\r\n    else if (isSet(val)) {\r\n        return {\r\n            [`Set(${val.size})`]: [...val.values()]\r\n        };\r\n    }\r\n    else if (isObject(val) && !isArray(val) && !isPlainObject(val)) {\r\n        return String(val);\r\n    }\r\n    return val;\r\n};\n\nconst EMPTY_OBJ = (process.env.NODE_ENV !== 'production')\r\n    ? Object.freeze({})\r\n    : {};\r\nconst EMPTY_ARR = (process.env.NODE_ENV !== 'production') ? Object.freeze([]) : [];\r\nconst NOOP = () => { };\r\n/**\r\n * Always return false.\r\n */\r\nconst NO = () => false;\r\nconst onRE = /^on[^a-z]/;\r\nconst isOn = (key) => onRE.test(key);\r\nconst isModelListener = (key) => key.startsWith('onUpdate:');\r\nconst extend = Object.assign;\r\nconst remove = (arr, el) => {\r\n    const i = arr.indexOf(el);\r\n    if (i > -1) {\r\n        arr.splice(i, 1);\r\n    }\r\n};\r\nconst hasOwnProperty = Object.prototype.hasOwnProperty;\r\nconst hasOwn = (val, key) => hasOwnProperty.call(val, key);\r\nconst isArray = Array.isArray;\r\nconst isMap = (val) => toTypeString(val) === '[object Map]';\r\nconst isSet = (val) => toTypeString(val) === '[object Set]';\r\nconst isDate = (val) => toTypeString(val) === '[object Date]';\r\nconst isFunction = (val) => typeof val === 'function';\r\nconst isString = (val) => typeof val === 'string';\r\nconst isSymbol = (val) => typeof val === 'symbol';\r\nconst isObject = (val) => val !== null && typeof val === 'object';\r\nconst isPromise = (val) => {\r\n    return isObject(val) && isFunction(val.then) && isFunction(val.catch);\r\n};\r\nconst objectToString = Object.prototype.toString;\r\nconst toTypeString = (value) => objectToString.call(value);\r\nconst toRawType = (value) => {\r\n    // extract \"RawType\" from strings like \"[object RawType]\"\r\n    return toTypeString(value).slice(8, -1);\r\n};\r\nconst isPlainObject = (val) => toTypeString(val) === '[object Object]';\r\nconst isIntegerKey = (key) => isString(key) &&\r\n    key !== 'NaN' &&\r\n    key[0] !== '-' &&\r\n    '' + parseInt(key, 10) === key;\r\nconst isReservedProp = /*#__PURE__*/ makeMap(\r\n// the leading comma is intentional so empty string \"\" is also included\r\n',key,ref,ref_for,ref_key,' +\r\n    'onVnodeBeforeMount,onVnodeMounted,' +\r\n    'onVnodeBeforeUpdate,onVnodeUpdated,' +\r\n    'onVnodeBeforeUnmount,onVnodeUnmounted');\r\nconst isBuiltInDirective = /*#__PURE__*/ makeMap('bind,cloak,else-if,else,for,html,if,model,on,once,pre,show,slot,text,memo');\r\nconst cacheStringFunction = (fn) => {\r\n    const cache = Object.create(null);\r\n    return ((str) => {\r\n        const hit = cache[str];\r\n        return hit || (cache[str] = fn(str));\r\n    });\r\n};\r\nconst camelizeRE = /-(\\w)/g;\r\n/**\r\n * @private\r\n */\r\nconst camelize = cacheStringFunction((str) => {\r\n    return str.replace(camelizeRE, (_, c) => (c ? c.toUpperCase() : ''));\r\n});\r\nconst hyphenateRE = /\\B([A-Z])/g;\r\n/**\r\n * @private\r\n */\r\nconst hyphenate = cacheStringFunction((str) => str.replace(hyphenateRE, '-$1').toLowerCase());\r\n/**\r\n * @private\r\n */\r\nconst capitalize = cacheStringFunction((str) => str.charAt(0).toUpperCase() + str.slice(1));\r\n/**\r\n * @private\r\n */\r\nconst toHandlerKey = cacheStringFunction((str) => str ? `on${capitalize(str)}` : ``);\r\n// compare whether a value has changed, accounting for NaN.\r\nconst hasChanged = (value, oldValue) => !Object.is(value, oldValue);\r\nconst invokeArrayFns = (fns, arg) => {\r\n    for (let i = 0; i < fns.length; i++) {\r\n        fns[i](arg);\r\n    }\r\n};\r\nconst def = (obj, key, value) => {\r\n    Object.defineProperty(obj, key, {\r\n        configurable: true,\r\n        enumerable: false,\r\n        value\r\n    });\r\n};\r\nconst toNumber = (val) => {\r\n    const n = parseFloat(val);\r\n    return isNaN(n) ? val : n;\r\n};\r\nlet _globalThis;\r\nconst getGlobalThis = () => {\r\n    return (_globalThis ||\r\n        (_globalThis =\r\n            typeof globalThis !== 'undefined'\r\n                ? globalThis\r\n                : typeof self !== 'undefined'\r\n                    ? self\r\n                    : typeof window !== 'undefined'\r\n                        ? window\r\n                        : typeof global !== 'undefined'\r\n                            ? global\r\n                            : {}));\r\n};\r\nconst identRE = /^[_$a-zA-Z\\xA0-\\uFFFF][_$a-zA-Z0-9\\xA0-\\uFFFF]*$/;\r\nfunction genPropsAccessExp(name) {\r\n    return identRE.test(name)\r\n        ? `__props.${name}`\r\n        : `__props[${JSON.stringify(name)}]`;\r\n}\n\nexport { EMPTY_ARR, EMPTY_OBJ, NO, NOOP, PatchFlagNames, camelize, capitalize, def, escapeHtml, escapeHtmlComment, extend, genPropsAccessExp, generateCodeFrame, getGlobalThis, hasChanged, hasOwn, hyphenate, includeBooleanAttr, invokeArrayFns, isArray, isBooleanAttr, isBuiltInDirective, isDate, isFunction, isGloballyWhitelisted, isHTMLTag, isIntegerKey, isKnownHtmlAttr, isKnownSvgAttr, isMap, isModelListener, isNoUnitNumericStyleProp, isObject, isOn, isPlainObject, isPromise, isReservedProp, isSSRSafeAttrName, isSVGTag, isSet, isSpecialBooleanAttr, isString, isSymbol, isVoidTag, looseEqual, looseIndexOf, makeMap, normalizeClass, normalizeProps, normalizeStyle, objectToString, parseStringStyle, propsToAttrMap, remove, slotFlagsText, stringifyStyle, toDisplayString, toHandlerKey, toNumber, toRawType, toTypeString };\n","import { isFunction } from \"@vue/shared\";\nimport { computed } from \"vue\";\nimport { useNuxtApp } from \"#app\";\nexport function useHead(meta) {\n  const resolvedMeta = isFunction(meta) ? computed(meta) : meta;\n  useNuxtApp()._useHead(resolvedMeta);\n}\nexport function useMeta(meta) {\n  return useHead(meta);\n}\n","import { defineAsyncComponent } from 'vue'\nimport { defineNuxtPlugin } from '#app'\n\nconst components = {}\n\nexport default defineNuxtPlugin(nuxtApp => {\n  for (const name in components) {\n    nuxtApp.vueApp.component(name, components[name])\n    nuxtApp.vueApp.component('Lazy' + name, components[name])\n  }\n})\n","// src/index.ts\nimport {\n  defineComponent,\n  inject,\n  onBeforeUnmount,\n  ref,\n  watchEffect,\n  unref,\n  shallowRef\n} from \"vue\";\n\n// src/constants.ts\nvar PROVIDE_KEY = `usehead`;\nvar HEAD_COUNT_KEY = `head:count`;\nvar HEAD_ATTRS_KEY = `data-head-attrs`;\nvar SELF_CLOSING_TAGS = [\"meta\", \"link\", \"base\"];\nvar BODY_TAG_ATTR_NAME = `data-meta-body`;\n\n// src/create-element.ts\nvar createElement = (tag, attrs, document) => {\n  const el = document.createElement(tag);\n  for (const key of Object.keys(attrs)) {\n    if (key === \"body\" && attrs.body === true) {\n      el.setAttribute(BODY_TAG_ATTR_NAME, \"true\");\n    } else {\n      let value = attrs[key];\n      if (key === \"renderPriority\" || key === \"key\" || value === false) {\n        continue;\n      }\n      if (key === \"children\") {\n        el.textContent = value;\n      } else {\n        el.setAttribute(key, value);\n      }\n    }\n  }\n  return el;\n};\n\n// src/stringify-attrs.ts\nvar stringifyAttrName = (str) => str.replace(/[\\s\"'><\\/=]/g, \"\").replace(/[^a-zA-Z0-9_-]/g, \"\");\nvar stringifyAttrValue = (str) => str.replace(/\"/g, \"&quot;\").replace(/</g, \"&lt;\").replace(/>/g, \"&gt;\");\nvar stringifyAttrs = (attributes) => {\n  const handledAttributes = [];\n  for (let [key, value] of Object.entries(attributes)) {\n    if (key === \"children\" || key === \"key\") {\n      continue;\n    }\n    if (value === false || value == null) {\n      continue;\n    }\n    let attribute = stringifyAttrName(key);\n    if (value !== true) {\n      attribute += `=\"${stringifyAttrValue(String(value))}\"`;\n    }\n    handledAttributes.push(attribute);\n  }\n  return handledAttributes.length > 0 ? \" \" + handledAttributes.join(\" \") : \"\";\n};\n\n// src/utils.ts\nfunction isEqualNode(oldTag, newTag) {\n  if (oldTag instanceof HTMLElement && newTag instanceof HTMLElement) {\n    const nonce = newTag.getAttribute(\"nonce\");\n    if (nonce && !oldTag.getAttribute(\"nonce\")) {\n      const cloneTag = newTag.cloneNode(true);\n      cloneTag.setAttribute(\"nonce\", \"\");\n      cloneTag.nonce = nonce;\n      return nonce === oldTag.nonce && oldTag.isEqualNode(cloneTag);\n    }\n  }\n  return oldTag.isEqualNode(newTag);\n}\n\n// src/index.ts\nvar tagDedupeKey = (tag) => {\n  if (![\"meta\", \"base\", \"script\", \"link\"].includes(tag.tag)) {\n    return false;\n  }\n  const { props, tag: tagName } = tag;\n  if (tagName === \"base\") {\n    return \"base\";\n  }\n  if (tagName === \"link\" && props.rel === \"canonical\") {\n    return \"canonical\";\n  }\n  if (props.charset) {\n    return \"charset\";\n  }\n  const name = [\"key\", \"id\", \"name\", \"property\", \"http-equiv\"];\n  for (const n of name) {\n    let value = void 0;\n    if (typeof props.getAttribute === \"function\" && props.hasAttribute(n)) {\n      value = props.getAttribute(n);\n    } else {\n      value = props[n];\n    }\n    if (value !== void 0) {\n      return `${tagName}-${n}-${value}`;\n    }\n  }\n  return false;\n};\nvar injectHead = () => {\n  const head = inject(PROVIDE_KEY);\n  if (!head) {\n    throw new Error(`You may forget to apply app.use(head)`);\n  }\n  return head;\n};\nvar acceptFields = [\n  \"title\",\n  \"meta\",\n  \"link\",\n  \"base\",\n  \"style\",\n  \"script\",\n  \"noscript\",\n  \"htmlAttrs\",\n  \"bodyAttrs\"\n];\nvar renderTemplate = (template, title) => {\n  if (template == null)\n    return \"\";\n  if (typeof template === \"string\") {\n    return template.replace(\"%s\", title ?? \"\");\n  }\n  return template(unref(title));\n};\nvar headObjToTags = (obj) => {\n  const tags = [];\n  const keys = Object.keys(obj);\n  for (const key of keys) {\n    if (obj[key] == null)\n      continue;\n    switch (key) {\n      case \"title\":\n        tags.push({ tag: key, props: { children: obj[key] } });\n        break;\n      case \"titleTemplate\":\n        break;\n      case \"base\":\n        tags.push({ tag: key, props: { key: \"default\", ...obj[key] } });\n        break;\n      default:\n        if (acceptFields.includes(key)) {\n          const value = obj[key];\n          if (Array.isArray(value)) {\n            value.forEach((item) => {\n              tags.push({ tag: key, props: unref(item) });\n            });\n          } else if (value) {\n            tags.push({ tag: key, props: value });\n          }\n        }\n        break;\n    }\n  }\n  return tags;\n};\nvar setAttrs = (el, attrs) => {\n  const existingAttrs = el.getAttribute(HEAD_ATTRS_KEY);\n  if (existingAttrs) {\n    for (const key of existingAttrs.split(\",\")) {\n      if (!(key in attrs)) {\n        el.removeAttribute(key);\n      }\n    }\n  }\n  const keys = [];\n  for (const key in attrs) {\n    const value = attrs[key];\n    if (value == null)\n      continue;\n    if (value === false) {\n      el.removeAttribute(key);\n    } else {\n      el.setAttribute(key, value);\n    }\n    keys.push(key);\n  }\n  if (keys.length) {\n    el.setAttribute(HEAD_ATTRS_KEY, keys.join(\",\"));\n  } else {\n    el.removeAttribute(HEAD_ATTRS_KEY);\n  }\n};\nvar updateElements = (document = window.document, type, tags) => {\n  var _a, _b;\n  const head = document.head;\n  const body = document.body;\n  let headCountEl = head.querySelector(`meta[name=\"${HEAD_COUNT_KEY}\"]`);\n  let bodyMetaElements = body.querySelectorAll(`[${BODY_TAG_ATTR_NAME}]`);\n  const headCount = headCountEl ? Number(headCountEl.getAttribute(\"content\")) : 0;\n  const oldHeadElements = [];\n  const oldBodyElements = [];\n  if (bodyMetaElements) {\n    for (let i = 0; i < bodyMetaElements.length; i++) {\n      if (bodyMetaElements[i] && ((_a = bodyMetaElements[i].tagName) == null ? void 0 : _a.toLowerCase()) === type) {\n        oldBodyElements.push(bodyMetaElements[i]);\n      }\n    }\n  }\n  if (headCountEl) {\n    for (let i = 0, j = headCountEl.previousElementSibling; i < headCount; i++, j = (j == null ? void 0 : j.previousElementSibling) || null) {\n      if (((_b = j == null ? void 0 : j.tagName) == null ? void 0 : _b.toLowerCase()) === type) {\n        oldHeadElements.push(j);\n      }\n    }\n  } else {\n    headCountEl = document.createElement(\"meta\");\n    headCountEl.setAttribute(\"name\", HEAD_COUNT_KEY);\n    headCountEl.setAttribute(\"content\", \"0\");\n    head.append(headCountEl);\n  }\n  let newElements = tags.map((tag) => ({\n    element: createElement(tag.tag, tag.props, document),\n    body: tag.props.body ?? false\n  }));\n  newElements = newElements.filter((newEl) => {\n    for (let i = 0; i < oldHeadElements.length; i++) {\n      const oldEl = oldHeadElements[i];\n      if (isEqualNode(oldEl, newEl.element)) {\n        oldHeadElements.splice(i, 1);\n        return false;\n      }\n    }\n    for (let i = 0; i < oldBodyElements.length; i++) {\n      const oldEl = oldBodyElements[i];\n      if (isEqualNode(oldEl, newEl.element)) {\n        oldBodyElements.splice(i, 1);\n        return false;\n      }\n    }\n    return true;\n  });\n  oldBodyElements.forEach((t) => {\n    var _a2;\n    return (_a2 = t.parentNode) == null ? void 0 : _a2.removeChild(t);\n  });\n  oldHeadElements.forEach((t) => {\n    var _a2;\n    return (_a2 = t.parentNode) == null ? void 0 : _a2.removeChild(t);\n  });\n  newElements.forEach((t) => {\n    if (t.body === true) {\n      body.insertAdjacentElement(\"beforeend\", t.element);\n    } else {\n      head.insertBefore(t.element, headCountEl);\n    }\n  });\n  headCountEl.setAttribute(\n    \"content\",\n    \"\" + (headCount - oldHeadElements.length + newElements.filter((t) => !t.body).length)\n  );\n};\nvar createHead = (initHeadObject) => {\n  let allHeadObjs = [];\n  let previousTags = /* @__PURE__ */ new Set();\n  if (initHeadObject) {\n    allHeadObjs.push(shallowRef(initHeadObject));\n  }\n  const head = {\n    install(app) {\n      app.config.globalProperties.$head = head;\n      app.provide(PROVIDE_KEY, head);\n    },\n    get headTags() {\n      const deduped = [];\n      const deduping = {};\n      const titleTemplate = allHeadObjs.map((i) => unref(i).titleTemplate).reverse().find((i) => i != null);\n      allHeadObjs.forEach((objs, headObjectIdx) => {\n        const tags = headObjToTags(unref(objs));\n        tags.forEach((tag, tagIdx) => {\n          tag._position = headObjectIdx * 1e4 + tagIdx;\n          if (titleTemplate && tag.tag === \"title\") {\n            tag.props.children = renderTemplate(\n              titleTemplate,\n              tag.props.children\n            );\n          }\n          const dedupeKey = tagDedupeKey(tag);\n          if (dedupeKey) {\n            deduping[dedupeKey] = tag;\n          } else {\n            deduped.push(tag);\n          }\n        });\n      });\n      deduped.push(...Object.values(deduping));\n      return deduped.sort((a, b) => a._position - b._position);\n    },\n    addHeadObjs(objs) {\n      allHeadObjs.push(objs);\n    },\n    removeHeadObjs(objs) {\n      allHeadObjs = allHeadObjs.filter((_objs) => _objs !== objs);\n    },\n    updateDOM(document = window.document) {\n      let title;\n      let htmlAttrs = {};\n      let bodyAttrs = {};\n      const actualTags = {};\n      for (const tag of head.headTags.sort(sortTags)) {\n        if (tag.tag === \"title\") {\n          title = tag.props.children;\n          continue;\n        }\n        if (tag.tag === \"htmlAttrs\") {\n          Object.assign(htmlAttrs, tag.props);\n          continue;\n        }\n        if (tag.tag === \"bodyAttrs\") {\n          Object.assign(bodyAttrs, tag.props);\n          continue;\n        }\n        actualTags[tag.tag] = actualTags[tag.tag] || [];\n        actualTags[tag.tag].push(tag);\n      }\n      if (title !== void 0) {\n        document.title = title;\n      }\n      setAttrs(document.documentElement, htmlAttrs);\n      setAttrs(document.body, bodyAttrs);\n      const tags = /* @__PURE__ */ new Set([...Object.keys(actualTags), ...previousTags]);\n      for (const tag of tags) {\n        updateElements(document, tag, actualTags[tag] || []);\n      }\n      previousTags.clear();\n      Object.keys(actualTags).forEach((i) => previousTags.add(i));\n    }\n  };\n  return head;\n};\nvar IS_BROWSER = typeof window !== \"undefined\";\nvar useHead = (obj) => {\n  const head = injectHead();\n  const headObj = ref(obj);\n  head.addHeadObjs(headObj);\n  if (IS_BROWSER) {\n    watchEffect(() => {\n      head.updateDOM();\n    });\n    onBeforeUnmount(() => {\n      head.removeHeadObjs(headObj);\n      head.updateDOM();\n    });\n  }\n};\nvar tagToString = (tag) => {\n  let isBodyTag = false;\n  if (tag.props.body) {\n    isBodyTag = true;\n    delete tag.props.body;\n  }\n  if (tag.props.renderPriority) {\n    delete tag.props.renderPriority;\n  }\n  let attrs = stringifyAttrs(tag.props);\n  if (SELF_CLOSING_TAGS.includes(tag.tag)) {\n    return `<${tag.tag}${attrs}${isBodyTag ? `  ${BODY_TAG_ATTR_NAME}=\"true\"` : \"\"}>`;\n  }\n  return `<${tag.tag}${attrs}${isBodyTag ? ` ${BODY_TAG_ATTR_NAME}=\"true\"` : \"\"}>${tag.props.children || \"\"}</${tag.tag}>`;\n};\nvar sortTags = (aTag, bTag) => {\n  const tagWeight = (tag) => {\n    if (tag.props.renderPriority) {\n      return tag.props.renderPriority;\n    }\n    switch (tag.tag) {\n      case \"base\":\n        return -1;\n      case \"meta\":\n        if (tag.props.charset) {\n          return -2;\n        }\n        if (tag.props[\"http-equiv\"] === \"content-security-policy\") {\n          return 0;\n        }\n        return 10;\n      default:\n        return 10;\n    }\n  };\n  return tagWeight(aTag) - tagWeight(bTag);\n};\nvar renderHeadToString = (head) => {\n  const tags = [];\n  let titleTag = \"\";\n  let htmlAttrs = {};\n  let bodyAttrs = {};\n  let bodyTags = [];\n  for (const tag of head.headTags.sort(sortTags)) {\n    if (tag.tag === \"title\") {\n      titleTag = tagToString(tag);\n    } else if (tag.tag === \"htmlAttrs\") {\n      Object.assign(htmlAttrs, tag.props);\n    } else if (tag.tag === \"bodyAttrs\") {\n      Object.assign(bodyAttrs, tag.props);\n    } else if (tag.props.body) {\n      bodyTags.push(tagToString(tag));\n    } else {\n      tags.push(tagToString(tag));\n    }\n  }\n  tags.push(`<meta name=\"${HEAD_COUNT_KEY}\" content=\"${tags.length}\">`);\n  return {\n    get headTags() {\n      return titleTag + tags.join(\"\");\n    },\n    get htmlAttrs() {\n      return stringifyAttrs({\n        ...htmlAttrs,\n        [HEAD_ATTRS_KEY]: Object.keys(htmlAttrs).join(\",\")\n      });\n    },\n    get bodyAttrs() {\n      return stringifyAttrs({\n        ...bodyAttrs,\n        [HEAD_ATTRS_KEY]: Object.keys(bodyAttrs).join(\",\")\n      });\n    },\n    get bodyTags() {\n      return bodyTags.join(\"\");\n    }\n  };\n};\nvar addVNodeToHeadObj = (node, obj) => {\n  const type = node.type === \"html\" ? \"htmlAttrs\" : node.type === \"body\" ? \"bodyAttrs\" : node.type;\n  if (typeof type !== \"string\" || !(type in obj))\n    return;\n  const props = {\n    ...node.props,\n    children: Array.isArray(node.children) ? node.children[0].children : node.children\n  };\n  if (Array.isArray(obj[type])) {\n    ;\n    obj[type].push(props);\n  } else if (type === \"title\") {\n    obj.title = props.children;\n  } else {\n    ;\n    obj[type] = props;\n  }\n};\nvar vnodesToHeadObj = (nodes) => {\n  const obj = {\n    title: void 0,\n    htmlAttrs: void 0,\n    bodyAttrs: void 0,\n    base: void 0,\n    meta: [],\n    link: [],\n    style: [],\n    script: [],\n    noscript: []\n  };\n  for (const node of nodes) {\n    if (typeof node.type === \"symbol\" && Array.isArray(node.children)) {\n      for (const childNode of node.children) {\n        addVNodeToHeadObj(childNode, obj);\n      }\n    } else {\n      addVNodeToHeadObj(node, obj);\n    }\n  }\n  return obj;\n};\nvar Head = /* @__PURE__ */ defineComponent({\n  name: \"Head\",\n  setup(_, { slots }) {\n    const head = injectHead();\n    let obj;\n    onBeforeUnmount(() => {\n      if (obj) {\n        head.removeHeadObjs(obj);\n        head.updateDOM();\n      }\n    });\n    return () => {\n      watchEffect(() => {\n        if (!slots.default)\n          return;\n        if (obj) {\n          head.removeHeadObjs(obj);\n        }\n        obj = ref(vnodesToHeadObj(slots.default()));\n        head.addHeadObjs(obj);\n        if (IS_BROWSER) {\n          head.updateDOM();\n        }\n      });\n      return null;\n    };\n  }\n});\nexport {\n  Head,\n  createHead,\n  injectHead,\n  renderHeadToString,\n  useHead\n};\n","import { createHead, renderHeadToString } from \"@vueuse/head\";\nimport { computed, ref, watchEffect, onBeforeUnmount, getCurrentInstance } from \"vue\";\nimport defu from \"defu\";\nimport { defineNuxtPlugin } from \"#app\";\nexport default defineNuxtPlugin((nuxtApp) => {\n  const head = createHead();\n  nuxtApp.vueApp.use(head);\n  let headReady = false;\n  nuxtApp.hooks.hookOnce(\"app:mounted\", () => {\n    watchEffect(() => {\n      head.updateDOM();\n    });\n    headReady = true;\n  });\n  nuxtApp._useHead = (_meta) => {\n    const meta = ref(_meta);\n    const headObj = computed(() => {\n      const overrides = { meta: [] };\n      if (meta.value.charset) {\n        overrides.meta.push({ key: \"charset\", charset: meta.value.charset });\n      }\n      if (meta.value.viewport) {\n        overrides.meta.push({ name: \"viewport\", content: meta.value.viewport });\n      }\n      return defu(overrides, meta.value);\n    });\n    head.addHeadObjs(headObj);\n    if (process.server) {\n      return;\n    }\n    if (headReady) {\n      watchEffect(() => {\n        head.updateDOM();\n      });\n    }\n    const vm = getCurrentInstance();\n    if (!vm) {\n      return;\n    }\n    onBeforeUnmount(() => {\n      head.removeHeadObjs(headObj);\n      head.updateDOM();\n    });\n  };\n  if (process.server) {\n    nuxtApp.ssrContext.renderMeta = () => {\n      const meta = renderHeadToString(head);\n      return {\n        ...meta,\n        bodyScripts: meta.bodyTags\n      };\n    };\n  }\n});\n","import { defineComponent } from \"vue\";\nimport { useHead } from \"./composables.mjs\";\nconst removeUndefinedProps = (props) => Object.fromEntries(Object.entries(props).filter(([, value]) => value !== void 0));\nconst setupForUseMeta = (metaFactory, renderChild) => (props, ctx) => {\n  useHead(() => metaFactory({ ...removeUndefinedProps(props), ...ctx.attrs }, ctx));\n  return () => renderChild ? ctx.slots.default?.() : null;\n};\nconst globalProps = {\n  accesskey: String,\n  autocapitalize: String,\n  autofocus: {\n    type: Boolean,\n    default: void 0\n  },\n  class: String,\n  contenteditable: {\n    type: Boolean,\n    default: void 0\n  },\n  contextmenu: String,\n  dir: String,\n  draggable: {\n    type: Boolean,\n    default: void 0\n  },\n  enterkeyhint: String,\n  exportparts: String,\n  hidden: {\n    type: Boolean,\n    default: void 0\n  },\n  id: String,\n  inputmode: String,\n  is: String,\n  itemid: String,\n  itemprop: String,\n  itemref: String,\n  itemscope: String,\n  itemtype: String,\n  lang: String,\n  nonce: String,\n  part: String,\n  slot: String,\n  spellcheck: {\n    type: Boolean,\n    default: void 0\n  },\n  style: String,\n  tabindex: String,\n  title: String,\n  translate: String\n};\nexport const Script = defineComponent({\n  name: \"Script\",\n  inheritAttrs: false,\n  props: {\n    ...globalProps,\n    async: Boolean,\n    crossorigin: {\n      type: [Boolean, String],\n      default: void 0\n    },\n    defer: Boolean,\n    fetchpriority: String,\n    integrity: String,\n    nomodule: Boolean,\n    nonce: String,\n    referrerpolicy: String,\n    src: String,\n    type: String,\n    charset: String,\n    language: String\n  },\n  setup: setupForUseMeta((script) => ({\n    script: [script]\n  }))\n});\nexport const NoScript = defineComponent({\n  name: \"NoScript\",\n  inheritAttrs: false,\n  props: {\n    ...globalProps,\n    title: String\n  },\n  setup: setupForUseMeta((props, { slots }) => {\n    const noscript = { ...props };\n    const textContent = (slots.default?.() || []).filter(({ children }) => children).map(({ children }) => children).join(\"\");\n    if (textContent) {\n      noscript.children = textContent;\n    }\n    return {\n      noscript: [noscript]\n    };\n  })\n});\nexport const Link = defineComponent({\n  name: \"Link\",\n  inheritAttrs: false,\n  props: {\n    ...globalProps,\n    as: String,\n    crossorigin: String,\n    disabled: Boolean,\n    fetchpriority: String,\n    href: String,\n    hreflang: String,\n    imagesizes: String,\n    imagesrcset: String,\n    integrity: String,\n    media: String,\n    prefetch: {\n      type: Boolean,\n      default: void 0\n    },\n    referrerpolicy: String,\n    rel: String,\n    sizes: String,\n    title: String,\n    type: String,\n    methods: String,\n    target: String\n  },\n  setup: setupForUseMeta((link) => ({\n    link: [link]\n  }))\n});\nexport const Base = defineComponent({\n  name: \"Base\",\n  inheritAttrs: false,\n  props: {\n    ...globalProps,\n    href: String,\n    target: String\n  },\n  setup: setupForUseMeta((base) => ({\n    base\n  }))\n});\nexport const Title = defineComponent({\n  name: \"Title\",\n  inheritAttrs: false,\n  setup: setupForUseMeta((_, { slots }) => {\n    const title = slots.default?.()?.[0]?.children || null;\n    if (process.dev && title && typeof title !== \"string\") {\n      console.error(\"<Title> can only take a string in its default slot.\");\n    }\n    return {\n      title\n    };\n  })\n});\nexport const Meta = defineComponent({\n  name: \"Meta\",\n  inheritAttrs: false,\n  props: {\n    ...globalProps,\n    charset: String,\n    content: String,\n    httpEquiv: String,\n    name: String\n  },\n  setup: setupForUseMeta((props) => {\n    const meta = { ...props };\n    if (meta.httpEquiv) {\n      meta[\"http-equiv\"] = meta.httpEquiv;\n      delete meta.httpEquiv;\n    }\n    return {\n      meta: [meta]\n    };\n  })\n});\nexport const Style = defineComponent({\n  name: \"Style\",\n  inheritAttrs: false,\n  props: {\n    ...globalProps,\n    type: String,\n    media: String,\n    nonce: String,\n    title: String,\n    scoped: {\n      type: Boolean,\n      default: void 0\n    }\n  },\n  setup: setupForUseMeta((props, { slots }) => {\n    const style = { ...props };\n    const textContent = slots.default?.()?.[0]?.children;\n    if (textContent) {\n      if (process.dev && typeof textContent !== \"string\") {\n        console.error(\"<Style> can only take a string in its default slot.\");\n      }\n      style.children = textContent;\n    }\n    return {\n      style: [style]\n    };\n  })\n});\nexport const Head = defineComponent({\n  name: \"Head\",\n  inheritAttrs: false,\n  setup: (_props, ctx) => () => ctx.slots.default?.()\n});\nexport const Html = defineComponent({\n  name: \"Html\",\n  inheritAttrs: false,\n  props: {\n    ...globalProps,\n    manifest: String,\n    version: String,\n    xmlns: String\n  },\n  setup: setupForUseMeta((htmlAttrs) => ({ htmlAttrs }), true)\n});\nexport const Body = defineComponent({\n  name: \"Body\",\n  inheritAttrs: false,\n  props: globalProps,\n  setup: setupForUseMeta((bodyAttrs) => ({ bodyAttrs }), true)\n});\n","export const appBaseURL = \"/RGB-Lamp-Display-Emulator\"\n\nexport const appBuildAssetsDir = \"/nuxt/\"\n\nexport const appCdnURL = \"/RGB-Lamp-Display-Emulator\"\n\nexport const appAssetsPath = {}\n\nexport const appHead = {\"meta\":[],\"link\":[],\"style\":[],\"script\":[],\"noscript\":[],\"charset\":\"utf-8\",\"viewport\":\"width=device-width, initial-scale=1\"}\n\nexport const appLayoutTransition = {\"name\":\"layout\",\"mode\":\"out-in\"}\n\nexport const appPageTransition = {\"name\":\"page\",\"mode\":\"out-in\"}\n\nexport const appKeepalive = false","import { computed, getCurrentInstance, markRaw } from \"vue\";\nimport * as Components from \"./components.mjs\";\nimport { useHead } from \"./composables.mjs\";\nimport { defineNuxtPlugin, useNuxtApp } from \"#app\";\nimport { appHead } from \"#build/nuxt.config.mjs\";\nconst metaMixin = {\n  created() {\n    const instance = getCurrentInstance();\n    if (!instance) {\n      return;\n    }\n    const options = instance.type;\n    if (!options || !(\"head\" in options)) {\n      return;\n    }\n    const nuxtApp = useNuxtApp();\n    const source = typeof options.head === \"function\" ? computed(() => options.head(nuxtApp)) : options.head;\n    useHead(source);\n  }\n};\nexport default defineNuxtPlugin((nuxtApp) => {\n  useHead(markRaw({ title: \"\", ...appHead }));\n  nuxtApp.vueApp.mixin(metaMixin);\n  for (const name in Components) {\n    nuxtApp.vueApp.component(name, Components[name]);\n  }\n});\n","import { KeepAlive, h } from \"vue\";\nconst interpolatePath = (route, match) => {\n  return match.path.replace(/(:\\w+)\\([^)]+\\)/g, \"$1\").replace(/(:\\w+)[?+*]/g, \"$1\").replace(/:\\w+/g, (r) => route.params[r.slice(1)]?.toString() || \"\");\n};\nexport const generateRouteKey = (override, routeProps) => {\n  const matchedRoute = routeProps.route.matched.find((m) => m.components?.default === routeProps.Component.type);\n  const source = override ?? matchedRoute?.meta.key ?? (matchedRoute && interpolatePath(routeProps.route, matchedRoute));\n  return typeof source === \"function\" ? source(routeProps.route) : source;\n};\nexport const wrapInKeepAlive = (props, children) => {\n  return { default: () => process.client && props ? h(KeepAlive, props === true ? {} : props, children) : children };\n};\n","import { defineComponent, h } from \"vue\";\nconst Fragment = defineComponent({\n  setup(_props, { slots }) {\n    return () => slots.default?.();\n  }\n});\nexport const _wrapIf = (component, props, slots) => {\n  return { default: () => props ? h(component, props === true ? {} : props, slots) : h(Fragment, {}, slots) };\n};\n","import { computed, defineComponent, h, inject, provide, reactive, onMounted, nextTick, Suspense, Transition } from \"vue\";\nimport { RouterView } from \"vue-router\";\nimport { generateRouteKey, wrapInKeepAlive } from \"./utils.mjs\";\nimport { useNuxtApp } from \"#app\";\nimport { _wrapIf } from \"#app/components/utils\";\nimport { appPageTransition as defaultPageTransition, appKeepalive as defaultKeepaliveConfig } from \"#build/nuxt.config.mjs\";\nconst isNestedKey = Symbol(\"isNested\");\nexport default defineComponent({\n  name: \"NuxtPage\",\n  inheritAttrs: false,\n  props: {\n    name: {\n      type: String\n    },\n    transition: {\n      type: [Boolean, Object],\n      default: void 0\n    },\n    keepalive: {\n      type: [Boolean, Object],\n      default: void 0\n    },\n    route: {\n      type: Object\n    },\n    pageKey: {\n      type: [Function, String],\n      default: null\n    }\n  },\n  setup(props, { attrs }) {\n    const nuxtApp = useNuxtApp();\n    const isNested = inject(isNestedKey, false);\n    provide(isNestedKey, true);\n    return () => {\n      return h(RouterView, { name: props.name, route: props.route, ...attrs }, {\n        default: (routeProps) => {\n          if (!routeProps.Component) {\n            return;\n          }\n          const key = generateRouteKey(props.pageKey, routeProps);\n          const transitionProps = props.transition ?? routeProps.route.meta.pageTransition ?? defaultPageTransition;\n          return _wrapIf(\n            Transition,\n            transitionProps,\n            wrapInKeepAlive(\n              props.keepalive ?? routeProps.route.meta.keepalive ?? defaultKeepaliveConfig,\n              isNested && nuxtApp.isHydrating ? h(Component, { key, routeProps, pageKey: key, hasTransition: !!transitionProps }) : h(Suspense, {\n                onPending: () => nuxtApp.callHook(\"page:start\", routeProps.Component),\n                onResolve: () => nuxtApp.callHook(\"page:finish\", routeProps.Component)\n              }, { default: () => h(Component, { key, routeProps, pageKey: key, hasTransition: !!transitionProps }) })\n            )\n          ).default();\n        }\n      });\n    };\n  }\n});\nconst Component = defineComponent({\n  props: [\"routeProps\", \"pageKey\", \"hasTransition\"],\n  setup(props) {\n    const previousKey = props.pageKey;\n    const previousRoute = props.routeProps.route;\n    const route = {};\n    for (const key in props.routeProps.route) {\n      route[key] = computed(() => previousKey === props.pageKey ? props.routeProps.route[key] : previousRoute[key]);\n    }\n    provide(\"_route\", reactive(route));\n    let vnode;\n    if (process.dev && process.client && props.hasTransition) {\n      onMounted(() => {\n        nextTick(() => {\n          if ([\"#comment\", \"#text\"].includes(vnode?.el?.nodeName)) {\n            const filename = (vnode?.type).__file;\n            console.warn(`[nuxt] \\`${filename}\\` does not have a single root node and will cause errors when navigating between routes.`);\n          }\n        });\n      });\n    }\n    return () => {\n      if (process.dev && process.client) {\n        vnode = h(props.routeProps.Component);\n        return vnode;\n      }\n      return h(props.routeProps.Component);\n    };\n  }\n});\n","import { meta as C_58_47WIP_32Projects_47RGB_45Lamp_45Display_45Emulator_47pages_47index_46vueMeta } from \"C:/WIP Projects/RGB-Lamp-Display-Emulator/pages/index.vue?macro=true\";\nexport default [\n  {\n    name: \"index\",\n    path: \"/\",\n    file: \"C:/WIP Projects/RGB-Lamp-Display-Emulator/pages/index.vue\",\n    children: [],\n    meta: C_58_47WIP_32Projects_47RGB_45Lamp_45Display_45Emulator_47pages_47index_46vueMeta,\n    alias: C_58_47WIP_32Projects_47RGB_45Lamp_45Display_45Emulator_47pages_47index_46vueMeta?.alias || [],\n    component: () => import(\"C:/WIP Projects/RGB-Lamp-Display-Emulator/pages/index.vue\").then(m => m.default || m)\n  }\n]","const configRouterOptions = {}\nexport default {\n...configRouterOptions,\n}","export const globalMiddleware = []\nexport const namedMiddleware = {}","import { computed, reactive, shallowRef } from \"vue\";\nimport {\n  createRouter,\n  createWebHistory,\n  createMemoryHistory,\n  createWebHashHistory\n} from \"vue-router\";\nimport { createError } from \"h3\";\nimport { withoutBase, isEqual } from \"ufo\";\nimport NuxtPage from \"./page.mjs\";\nimport { callWithNuxt, defineNuxtPlugin, useRuntimeConfig, showError, clearError, navigateTo, useError, useState } from \"#app\";\nimport _routes from \"#build/routes\";\nimport routerOptions from \"#build/router.options\";\nimport { globalMiddleware, namedMiddleware } from \"#build/middleware\";\nfunction createCurrentLocation(base, location) {\n  const { pathname, search, hash } = location;\n  const hashPos = base.indexOf(\"#\");\n  if (hashPos > -1) {\n    const slicePos = hash.includes(base.slice(hashPos)) ? base.slice(hashPos).length : 1;\n    let pathFromHash = hash.slice(slicePos);\n    if (pathFromHash[0] !== \"/\") {\n      pathFromHash = \"/\" + pathFromHash;\n    }\n    return withoutBase(pathFromHash, \"\");\n  }\n  const path = withoutBase(pathname, base);\n  return path + search + hash;\n}\nexport default defineNuxtPlugin(async (nuxtApp) => {\n  nuxtApp.vueApp.component(\"NuxtPage\", NuxtPage);\n  nuxtApp.vueApp.component(\"NuxtNestedPage\", NuxtPage);\n  nuxtApp.vueApp.component(\"NuxtChild\", NuxtPage);\n  let routerBase = useRuntimeConfig().app.baseURL;\n  if (routerOptions.hashMode && !routerBase.includes(\"#\")) {\n    routerBase += \"#\";\n  }\n  const history = routerOptions.history?.(routerBase) ?? (process.client ? routerOptions.hashMode ? createWebHashHistory(routerBase) : createWebHistory(routerBase) : createMemoryHistory(routerBase));\n  const routes = routerOptions.routes?.(_routes) ?? _routes;\n  const initialURL = process.server ? nuxtApp.ssrContext.url : createCurrentLocation(routerBase, window.location);\n  const router = createRouter({\n    ...routerOptions,\n    history,\n    routes\n  });\n  nuxtApp.vueApp.use(router);\n  const previousRoute = shallowRef(router.currentRoute.value);\n  router.afterEach((_to, from) => {\n    previousRoute.value = from;\n  });\n  Object.defineProperty(nuxtApp.vueApp.config.globalProperties, \"previousRoute\", {\n    get: () => previousRoute.value\n  });\n  const _route = shallowRef(router.resolve(initialURL));\n  const syncCurrentRoute = () => {\n    _route.value = router.currentRoute.value;\n  };\n  nuxtApp.hook(\"page:finish\", syncCurrentRoute);\n  router.afterEach((to, from) => {\n    if (to.matched[0]?.components?.default === from.matched[0]?.components?.default) {\n      syncCurrentRoute();\n    }\n  });\n  const route = {};\n  for (const key in _route.value) {\n    route[key] = computed(() => _route.value[key]);\n  }\n  nuxtApp._route = reactive(route);\n  nuxtApp._middleware = nuxtApp._middleware || {\n    global: [],\n    named: {}\n  };\n  const error = useError();\n  try {\n    if (process.server) {\n      await router.push(initialURL);\n    }\n    await router.isReady();\n  } catch (error2) {\n    callWithNuxt(nuxtApp, showError, [error2]);\n  }\n  const initialLayout = useState(\"_layout\");\n  router.beforeEach(async (to, from) => {\n    to.meta = reactive(to.meta);\n    if (nuxtApp.isHydrating) {\n      to.meta.layout = initialLayout.value ?? to.meta.layout;\n    }\n    nuxtApp._processingMiddleware = true;\n    const middlewareEntries = /* @__PURE__ */ new Set([...globalMiddleware, ...nuxtApp._middleware.global]);\n    for (const component of to.matched) {\n      const componentMiddleware = component.meta.middleware;\n      if (!componentMiddleware) {\n        continue;\n      }\n      if (Array.isArray(componentMiddleware)) {\n        for (const entry of componentMiddleware) {\n          middlewareEntries.add(entry);\n        }\n      } else {\n        middlewareEntries.add(componentMiddleware);\n      }\n    }\n    for (const entry of middlewareEntries) {\n      const middleware = typeof entry === \"string\" ? nuxtApp._middleware.named[entry] || await namedMiddleware[entry]?.().then((r) => r.default || r) : entry;\n      if (!middleware) {\n        if (process.dev) {\n          throw new Error(`Unknown route middleware: '${entry}'. Valid middleware: ${Object.keys(namedMiddleware).map((mw) => `'${mw}'`).join(\", \")}.`);\n        }\n        throw new Error(`Unknown route middleware: '${entry}'.`);\n      }\n      const result = await callWithNuxt(nuxtApp, middleware, [to, from]);\n      if (process.server || !nuxtApp.payload.serverRendered && nuxtApp.isHydrating) {\n        if (result === false || result instanceof Error) {\n          const error2 = result || createError({\n            statusMessage: `Route navigation aborted: ${initialURL}`\n          });\n          return callWithNuxt(nuxtApp, showError, [error2]);\n        }\n      }\n      if (result || result === false) {\n        return result;\n      }\n    }\n  });\n  router.afterEach(async (to) => {\n    delete nuxtApp._processingMiddleware;\n    if (process.client && !nuxtApp.isHydrating && error.value) {\n      await callWithNuxt(nuxtApp, clearError);\n    }\n    if (to.matched.length === 0) {\n      callWithNuxt(nuxtApp, showError, [createError({\n        statusCode: 404,\n        fatal: false,\n        statusMessage: `Page not found: ${to.fullPath}`\n      })]);\n    } else if (process.server && to.matched[0].name === \"404\" && nuxtApp.ssrContext) {\n      nuxtApp.ssrContext.event.res.statusCode = 404;\n    } else if (process.server) {\n      const currentURL = to.fullPath || \"/\";\n      if (!isEqual(currentURL, initialURL)) {\n        await callWithNuxt(nuxtApp, navigateTo, [currentURL]);\n      }\n    }\n  });\n  nuxtApp.hooks.hookOnce(\"app:created\", async () => {\n    try {\n      await router.replace({\n        ...router.resolve(initialURL),\n        name: void 0,\n        force: true\n      });\n    } catch (error2) {\n      callWithNuxt(nuxtApp, showError, [error2]);\n    }\n  });\n  return { provide: { router } };\n});\n","import _nuxt_components_plugin_mjs_KR1HBZs4kY from \"C:/WIP Projects/RGB-Lamp-Display-Emulator/.nuxt/components.plugin.mjs\";\nimport node_modules_nuxt_dist_head_runtime_lib_vueuse_head_plugin_mjs_D7WGfuP1A0 from \"C:/WIP Projects/RGB-Lamp-Display-Emulator/node_modules/nuxt/dist/head/runtime/lib/vueuse-head.plugin.mjs\";\nimport node_modules_nuxt_dist_head_runtime_plugin_mjs_1QO0gqa6n2 from \"C:/WIP Projects/RGB-Lamp-Display-Emulator/node_modules/nuxt/dist/head/runtime/plugin.mjs\";\nimport node_modules_nuxt_dist_pages_runtime_router_mjs_qNv5Ky2ZmB from \"C:/WIP Projects/RGB-Lamp-Display-Emulator/node_modules/nuxt/dist/pages/runtime/router.mjs\";\nexport default [\n  _nuxt_components_plugin_mjs_KR1HBZs4kY,\n  node_modules_nuxt_dist_head_runtime_lib_vueuse_head_plugin_mjs_D7WGfuP1A0,\n  node_modules_nuxt_dist_head_runtime_plugin_mjs_1QO0gqa6n2,\n  node_modules_nuxt_dist_pages_runtime_router_mjs_qNv5Ky2ZmB\n]","import { defineAsyncComponent } from 'vue'\nexport default {\n  default: defineAsyncComponent(() => import(\"C:/WIP Projects/RGB-Lamp-Display-Emulator/layouts/default.vue\").then(m => m.default || m))\n}","import { defineComponent, isRef, nextTick, onMounted, Transition } from \"vue\";\nimport { _wrapIf } from \"./utils.mjs\";\nimport { useRoute } from \"#app\";\nimport layouts from \"#build/layouts\";\nimport { appLayoutTransition as defaultLayoutTransition } from \"#build/nuxt.config.mjs\";\nexport default defineComponent({\n  props: {\n    name: {\n      type: [String, Boolean, Object],\n      default: null\n    }\n  },\n  setup(props, context) {\n    const route = useRoute();\n    let vnode;\n    let _layout;\n    if (process.dev && process.client) {\n      onMounted(() => {\n        nextTick(() => {\n          if (_layout && [\"#comment\", \"#text\"].includes(vnode?.el?.nodeName)) {\n            console.warn(`[nuxt] \\`${_layout}\\` layout does not have a single root node and will cause errors when navigating between routes.`);\n          }\n        });\n      });\n    }\n    return () => {\n      const layout = (isRef(props.name) ? props.name.value : props.name) ?? route.meta.layout ?? \"default\";\n      const hasLayout = layout && layout in layouts;\n      if (process.dev && layout && !hasLayout && layout !== \"default\") {\n        console.warn(`Invalid layout \\`${layout}\\` selected.`);\n      }\n      const transitionProps = route.meta.layoutTransition ?? defaultLayoutTransition;\n      return _wrapIf(Transition, hasLayout && transitionProps, {\n        default: () => {\n          if (process.dev && process.client && transitionProps) {\n            _layout = layout;\n            vnode = _wrapIf(layouts[layout], hasLayout, context.slots).default();\n            return vnode;\n          }\n          return _wrapIf(layouts[layout], hasLayout, context.slots).default();\n        }\n      }).default();\n    };\n  }\n});\n","import { createSSRApp, createApp, nextTick } from \"vue\";\nimport { $fetch } from \"ohmyfetch\";\nimport { baseURL } from \"#build/paths.mjs\";\nimport { createNuxtApp, applyPlugins, normalizePlugins } from \"#app\";\nimport \"#build/css\";\nimport _plugins from \"#build/plugins\";\nimport RootComponent from \"#build/root-component.mjs\";\nimport AppComponent from \"#build/app-component.mjs\";\nif (!globalThis.$fetch) {\n  globalThis.$fetch = $fetch.create({\n    baseURL: baseURL()\n  });\n}\nlet entry;\nconst plugins = normalizePlugins(_plugins);\nif (process.server) {\n  entry = async function createNuxtAppServer(ssrContext) {\n    const vueApp = createApp(RootComponent);\n    vueApp.component(\"App\", AppComponent);\n    const nuxt = createNuxtApp({ vueApp, ssrContext });\n    try {\n      await applyPlugins(nuxt, plugins);\n      await nuxt.hooks.callHook(\"app:created\", vueApp);\n    } catch (err) {\n      await nuxt.callHook(\"app:error\", err);\n      nuxt.payload.error = nuxt.payload.error || err;\n    }\n    return vueApp;\n  };\n}\nif (process.client) {\n  if (process.dev && import.meta.webpackHot) {\n    import.meta.webpackHot.accept();\n  }\n  entry = async function initApp() {\n    const isSSR = Boolean(window.__NUXT__?.serverRendered);\n    const vueApp = isSSR ? createSSRApp(RootComponent) : createApp(RootComponent);\n    vueApp.component(\"App\", AppComponent);\n    const nuxt = createNuxtApp({ vueApp });\n    nuxt.hooks.hookOnce(\"app:suspense:resolve\", () => {\n      nuxt.isHydrating = false;\n    });\n    try {\n      await applyPlugins(nuxt, plugins);\n    } catch (err) {\n      await nuxt.callHook(\"app:error\", err);\n      nuxt.payload.error = nuxt.payload.error || err;\n    }\n    try {\n      await nuxt.hooks.callHook(\"app:created\", vueApp);\n      await nuxt.hooks.callHook(\"app:beforeMount\", vueApp);\n      vueApp.mount(\"#__nuxt\");\n      await nuxt.hooks.callHook(\"app:mounted\", vueApp);\n      await nextTick();\n    } catch (err) {\n      await nuxt.callHook(\"app:error\", err);\n      nuxt.payload.error = nuxt.payload.error || err;\n    }\n  };\n  entry().catch((error) => {\n    console.error(\"Error while mounting app:\", error);\n  });\n}\nexport default (ctx) => entry(ctx);\n"],"file":"server.mjs"}